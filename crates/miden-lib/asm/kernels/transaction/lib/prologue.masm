use.std::mem
use.std::collections::mmr
use.std::crypto::hashes::rpo

use.kernel::account
use.kernel::asset_vault
use.kernel::constants
use.kernel::memory

# CONSTS
# =================================================================================================

# Max U32 value, used for initializing the expiration block number
const.MAX_BLOCK_NUM=0xFFFFFFFF

#Â ERRORS
# =================================================================================================

const.ERR_PROLOGUE_GLOBAL_INPUTS_PROVIDED_DO_NOT_MATCH_BLOCK_COMMITMENT="the provided global inputs do not match the block commitment"

const.ERR_PROLOGUE_GLOBAL_INPUTS_PROVIDED_DO_NOT_MATCH_BLOCK_NUMBER_COMMITMENT="the provided global inputs do not match the block number commitment"

const.ERR_PROLOGUE_NEW_ACCOUNT_VAULT_MUST_BE_EMPTY="new account must have an empty vault"

const.ERR_PROLOGUE_NEW_FUNGIBLE_FAUCET_RESERVED_SLOT_MUST_BE_EMPTY="reserved slot for new fungible faucet is not empty"

const.ERR_PROLOGUE_NEW_FUNGIBLE_FAUCET_RESERVED_SLOT_INVALID_TYPE="reserved slot for new fungible faucet has an invalid type"

const.ERR_PROLOGUE_NEW_NON_FUNGIBLE_FAUCET_RESERVED_SLOT_MUST_BE_VALID_EMPY_SMT="reserved slot for non-fungible faucet is not a valid empty SMT"

const.ERR_PROLOGUE_NEW_NON_FUNGIBLE_FAUCET_RESERVED_SLOT_INVALID_TYPE="reserved slot for new non-fungible faucet has an invalid type"

const.ERR_PROLOGUE_PROVIDED_ACCOUNT_DATA_DOES_NOT_MATCH_ON_CHAIN_COMMITMENT="account data provided does not match the commitment recorded on-chain"

const.ERR_PROLOGUE_EXISTING_ACCOUNT_MUST_HAVE_NON_ZERO_NONCE="existing accounts must have a non-zero nonce"

const.ERR_PROLOGUE_MISMATCH_OF_ACCOUNT_IDS_FROM_GLOBAL_INPUTS_AND_ADVICE_PROVIDER="account IDs provided via global inputs and advice provider do not match"

const.ERR_PROLOGUE_MISMATCH_OF_REFERENCE_BLOCK_MMR_AND_NOTE_AUTHENTICATION_MMR="reference block MMR and note's authentication MMR must match"

const.ERR_PROLOGUE_NUMBER_OF_NOTE_ASSETS_EXCEEDS_LIMIT="number of note assets exceeds the maximum limit of 256"

const.ERR_PROLOGUE_PROVIDED_INPUT_ASSETS_INFO_DOES_NOT_MATCH_ITS_COMMITMENT="provided info about assets of an input does not match its commitment"

const.ERR_PROLOGUE_NUMBER_OF_INPUT_NOTES_EXCEEDS_LIMIT="number of input notes exceeds the kernel's maximum limit of 1024"

const.ERR_PROLOGUE_INPUT_NOTES_COMMITMENT_MISMATCH="note commitment computed from the input note data does not match given note commitment"

const.ERR_PROLOGUE_NEW_ACCOUNT_NONCE_MUST_BE_ZERO="new account must have a zero nonce"

const.ERR_PROLOGUE_NUMBER_OF_NOTE_INPUTS_EXCEEDED_LIMIT="number of note inputs exceeded the maximum limit of 128"

# PUBLIC INPUTS
# =================================================================================================

#! Saves global inputs to memory.
#!
#! Inputs: [
#!   BLOCK_COMMITMENT,
#!   INITIAL_ACCOUNT_COMMITMENT,
#!   INPUT_NOTES_COMMITMENT,
#!   account_id_prefix, account_id_suffix, block_num
#! ]
#! Outputs: [block_num]
#!
#! Where:
#! - BLOCK_COMMITMENT is the reference block for the transaction execution.
#! - block_num is the number of the reference block.
#! - account_id_{prefix,suffix} are the prefix and suffix felts of the account ID of the account
#!   that the transaction is being executed against.
#! - INITIAL_ACCOUNT_COMMITMENT is the account state prior to the transaction, EMPTY_WORD for new
#!   accounts.
#! - INPUT_NOTES_COMMITMENT is the commitment to the input notes. See the
#!   `tx_get_input_notes_commitment` kernel procedure for details.
proc.process_global_inputs
    exec.memory::set_block_commitment dropw
    exec.memory::set_init_account_commitment dropw
    exec.memory::set_nullifier_commitment dropw
    exec.memory::set_global_acct_id
end

# KERNEL DATA
# =================================================================================================

#! Saves the procedure roots of the chosen kernel to memory. Verifies that kernel commitment and kernel
#! hash match the sequential hash of all kernels and sequential hash of kernel procedures
#! respectively.
#!
#! Inputs:
#!   Operand stack: []
#!   Advice stack:  [kernel_version]
#!   Advice map: {
#!     TX_KERNEL_COMMITMENT: [KERNEL_COMMITMENTS]
#!     KERNEL_COMMITMENT: [KERNEL_PROCEDURE_ROOTS]
#!   }
#! Outputs:
#!   Operand stack: []
#!   Advice stack:  []
#!
#! Where:
#! - kernel_version is the index of the desired kernel in the array of all kernels available for the
#!   current transaction.
#! - TX_KERNEL_COMMITMENT is the accumulative hash from all kernel commitments.
#! - [KERNEL_COMMITMENTS] is the array of each kernel commitment.
#! - [KERNEL_PROCEDURE_ROOTS] is the array of procedure roots of the current kernel.
proc.process_kernel_data
    # move the kernel offset to the operand stack
    adv_push.1
    # OS => [kernel_version]
    # AS => []

    # load the tx kernel commitment from memory
    exec.memory::get_tx_kernel_commitment
    # OS => [TX_KERNEL_COMMITMENT, kernel_version]
    # AS => []

    # push the kernel commitments from the advice map to the advice stack
    adv.push_mapvaln
    # OS => [TX_KERNEL_COMMITMENT, kernel_version]
    # AS => [len_felts, [KERNEL_COMMITMENTS]]

    # move the number of felt elements in the [KERNEL_COMMITMENTS] array to the stack and get the
    # number of Words from it
    adv_push.1 div.4
    # OS => [len_words, TX_KERNEL_COMMITMENT, kernel_version]
    # AS => [[KERNEL_COMMITMENTS]]

    # get the pointer to the memory where kernel commitments will be stored
    # Note: for now we use the same address for kernel commitment and for kernel procedures since there is
    # only one kernel and its hash will be overwritten by the procedures anyway.
    exec.memory::get_kernel_procedures_ptr swap
    # OS => [len_words, kernel_mem_ptr, TX_KERNEL_COMMITMENT, kernel_version]
    # AS => [[KERNEL_COMMITMENTS]]

    # store the kernel commitments in memory
    exec.mem::pipe_words_to_memory
    # OS => [C, B, A, kernel_mem_ptr', TX_KERNEL_COMMITMENT, kernel_version]
    # AS => []

    # extract the resulting hash
    exec.rpo::squeeze_digest
    # OS => [SEQ_HASH, kernel_mem_ptr', TX_KERNEL_COMMITMENT, kernel_version]
    # AS => []

    # assert that sequential hash matches the precomputed kernel commitment
    movup.4 drop assert_eqw
    # OS => [kernel_version]
    # AS => []

    # get the hash of the kernel which will be used in the current transaction
    exec.memory::get_kernel_procedures_ptr add
    # OS => [kernel_ptr]
    # AS => []

    padw movup.4 mem_loadw
    # OS => [KERNEL_COMMITMENT]
    # AS => []

    # push the procedure roots of the chosen kernel from the advice map to the advice stack
    adv.push_mapvaln
    # OS => [KERNEL_COMMITMENT]
    # AS => [len_felts, [PROC_HASHES]]

    # move the number of felt elements in the [PROC_HASHES] array to the stack and get the
    # number of Words from it
    adv_push.1 div.4
    # OS => [len_words, KERNEL_COMMITMENT]
    # AS => [[PROC_HASHES]]

    # store the number of the procedures of the chosen kernel to the memory
    dup exec.memory::set_num_kernel_procedures
    # OS => [len_words, KERNEL_COMMITMENT]
    # AS => [[PROC_HASHES]]

    # get the pointer to the memory where hashes of the kernel procedures will be stored
    exec.memory::get_kernel_procedures_ptr swap
    # OS => [len_words, kernel_procs_ptr, KERNEL_COMMITMENT]
    # AS => [[PROC_HASHES]]

    # store the kernel procedures to the memory
    exec.mem::pipe_words_to_memory
    # OS => [C, B, A, kernel_procs_ptr', KERNEL_COMMITMENT]
    # AS => []

    # extract the resulting hash
    exec.rpo::squeeze_digest
    # OS => [SEQ_HASH, kernel_procs_ptr', KERNEL_COMMITMENT]
    # AS => []

    # assert that the precomputed hash matches the computed one
    movup.4 drop assert_eqw
    # OS => []
    # AS => []
end

# BLOCK DATA
# =================================================================================================

#! Saves block data to memory and verifies that it matches the BLOCK_COMMITMENT public input.
#!
#! Inputs:
#!   Operand stack: [block_num]
#!   Advice stack: [
#!     PREV_BLOCK_COMMITMENT,
#!     PARTIAL_BLOCKCHAIN_COMMITMENT,
#!     ACCOUNT_ROOT,
#!     NULLIFIER_ROOT,
#!     TX_COMMITMENT,
#!     TX_KERNEL_COMMITMENT
#!     PROOF_COMMITMENT,
#!     [block_num, version, timestamp, 0],
#!     NOTE_ROOT,
#!   ]
#! Outputs:
#!   Operand stack: []
#!
#! Where:
#! - PREV_BLOCK_COMMITMENT is the commitment to the previous block.
#! - PARTIAL_BLOCKCHAIN_COMMITMENT is the sequential hash of the reference MMR.
#! - ACCOUNT_ROOT is the root of the tree with latest account states for all accounts.
#! - NULLIFIER_ROOT is the root of the tree with nullifiers of all notes that have ever been
#!   consumed.
#! - TX_COMMITMENT is a commitment to the set of transaction IDs which affected accounts in the block.
#! - TX_KERNEL_COMMITMENT is the accumulative hash from all kernel commitments.
#! - PROOF_COMMITMENT is the commitment of the block's STARK proof attesting to the correct state transition.
#! - block_num is the reference block number.
#! - version is the current protocol version.
#! - timestamp is the current timestamp.
#! - NOTE_ROOT is the root of the tree with all notes created in the block.
proc.process_block_data
    exec.memory::get_block_data_ptr
    # => [block_data_ptr, block_num]

    # read block data and compute its subhash. See `Advice stack` above for details.
    padw padw padw
    adv_pipe hperm
    adv_pipe hperm
    adv_pipe hperm
    adv_pipe hperm
    exec.rpo::squeeze_digest
    # => [DIG, block_data_ptr', block_num]

    # store the note root in memory
    padw adv_loadw
    dupw exec.memory::set_note_root dropw
    # => [NOTE_ROOT, DIG, block_data_ptr', block_num]

    # merge the note root with the block data digest
    hmerge
    # => [BLOCK_COMMITMENT, block_data_ptr', block_num]

    # assert that the block commitment matches the commitment in global inputs
    exec.memory::get_block_commitment
    assert_eqw.err=ERR_PROLOGUE_GLOBAL_INPUTS_PROVIDED_DO_NOT_MATCH_BLOCK_COMMITMENT
    # => [block_data_ptr', block_num]

    drop
    # => [block_num]

    exec.memory::get_blk_num
    assert_eq.err=ERR_PROLOGUE_GLOBAL_INPUTS_PROVIDED_DO_NOT_MATCH_BLOCK_NUMBER_COMMITMENT
end

# CHAIN DATA
# =================================================================================================

#! Saves the MMR peaks to memory and verifies that it matches the reference block's PARTIAL_BLOCKCHAIN_COMMITMENT.
#!
#! This procedure loads the MMR peaks from the advice provider, verifies their hash matches the
#! reference block, and insert the reference block in the MMR. The reference block is added to the
#! MMR so that notes created at this block can be consumed, since the MMR can't contain it and is
#! always one block behind. The number MMR peaks is variable, from 16 up to 63, depending on
#! `num_blocks`.
#!
#! Inputs:
#!   Operand stack: []
#!   Advice map: {
#!     PARTIAL_BLOCKCHAIN_COMMITMENT: [[num_blocks, 0, 0, 0], PEAK_1, ..., PEAK_N]
#!   }
#! Outputs:
#!   Operand stack: []
#!
#! Where:
#! - PARTIAL_BLOCKCHAIN_COMMITMENT is the sequential hash of the padded MMR peaks.
#! - num_blocks is the number of blocks in the MMR.
#! - PEAK_1 .. PEAK_N are the MMR peaks.
proc.process_chain_data
    exec.memory::get_partial_blockchain_ptr dup
    # => [partial_blockchain_ptr, partial_blockchain_ptr]

    # save the MMR peaks to memory and verify it matches the block's CHAIN_COMMITMENT
    exec.memory::get_chain_commitment
    exec.mmr::unpack
    # => [partial_blockchain_ptr]

    # add the current block's commitment to the MMR, enabling authentication of notes created in it
    exec.memory::get_block_commitment
    exec.mmr::add
    # => []
end

# ACCOUNT DATA
# =================================================================================================

#! Validates that the account the transaction is being executed against satisfies the criteria
#! for a new account.
#!
#! Applies the following validation to the new account:
#! - assert that the account ID is valid.
#! - assert that the account vault is empty.
#! - assert that the account nonce is set to 0.
#! - read the account seed from the advice provider and assert it satisfies seed requirements.
#!
#! Inputs:  []
#! Outputs: []
proc.validate_new_account
    # Assert the account ID of the account is valid
    exec.memory::get_account_id exec.account::validate_id
    # => []

    # Assert the account nonce is 0
    exec.memory::get_acct_nonce eq.0 assert.err=ERR_PROLOGUE_NEW_ACCOUNT_NONCE_MUST_BE_ZERO
    # => []

    # Assert the initial vault is empty
    # ---------------------------------------------------------------------------------------------
    # get the account vault root
    exec.memory::get_acct_vault_root
    # => [ACCT_VAULT_ROOT]

    # push empty vault root onto stack
    exec.constants::get_empty_smt_root
    # => [EMPTY_VAULT_ROOT, ACCT_VAULT_ROOT]

    assert_eqw.err=ERR_PROLOGUE_NEW_ACCOUNT_VAULT_MUST_BE_EMPTY
    # => []

    # Assert faucet reserved slot is correctly initialized
    # ---------------------------------------------------------------------------------------------
    # check if the account is a faucet
    exec.account::get_id swap drop dup exec.account::is_faucet
    # => [is_faucet, acct_id_prefix]

    # process conditional logic depending on whether the account is a faucet
    if.true
        # get the faucet reserved slot
        exec.account::get_faucet_storage_data_slot exec.account::get_item
        # => [FAUCET_RESERVED_SLOT, acct_id_prefix]

        # check if the account is a fungible faucet
        movup.4 exec.account::is_fungible_faucet
        # => [is_fungible_faucet, FAUCET_RESERVED_SLOT]

        if.true
            # assert the fungible faucet reserved slot is initialized correctly (EMPTY_WORD)
            # TODO: Switch to standard library implementation when available (miden-vm/#1483)
            exec.is_empty_word_dropped not
            assertz.err=ERR_PROLOGUE_NEW_FUNGIBLE_FAUCET_RESERVED_SLOT_MUST_BE_EMPTY
            # => []

            # get the faucet reserved storage data slot type
            exec.account::get_faucet_storage_data_slot exec.account::get_storage_slot_type
            # => [slot_type]

            # assert the fungible faucet reserved slot type == value
            exec.constants::get_storage_slot_type_value eq
            assert.err=ERR_PROLOGUE_NEW_FUNGIBLE_FAUCET_RESERVED_SLOT_INVALID_TYPE
            # => []
        else
            # assert the non-fungible faucet reserved slot is initialized correctly (root of
            # empty SMT)
            exec.constants::get_empty_smt_root
            assert_eqw.err=ERR_PROLOGUE_NEW_NON_FUNGIBLE_FAUCET_RESERVED_SLOT_MUST_BE_VALID_EMPY_SMT
            # => []

            # get the faucet reserved storage data slot type
            exec.account::get_faucet_storage_data_slot exec.account::get_storage_slot_type
            # => [slot_type]

            # assert the non-fungible faucet reserved slot type == map
            exec.constants::get_storage_slot_type_map eq
            assert.err=ERR_PROLOGUE_NEW_NON_FUNGIBLE_FAUCET_RESERVED_SLOT_INVALID_TYPE
            # => []
        end
    else
        # drop the hi part of the ID
        drop
        # => []
    end

    # Assert the provided account seed satisfies the seed requirements
    # ---------------------------------------------------------------------------------------------
    exec.account::validate_seed
    # => []

    # Assert the provided procedures offsets and sizes satisfy storage requirements
    # ---------------------------------------------------------------------------------------------
    exec.account::validate_procedure_metadata
    # => []
end

#! Returns whether the input word is equal to EMPTY_WORD as a boolean value.
#!
#! This procedure drops the input word.
#!
#! Inputs:  [INPUT_WORD]
#! Outputs: [is_empty]
#!
#! Where:
#! - INPUT_WORD is the word is compared with EMPTY_WORD.
#! - is_empty is a boolean value that is 1 if INPUT_WORD is equal to EMPTY_WORD, and 0 otherwise.
proc.is_empty_word_dropped
    eq.0 swap eq.0 and swap eq.0 and swap eq.0 and
end

#! Saves the account data to memory and validates it.
#!
#! This procedure will:
#! - Read the account data from the advice stack.
#! - Save it to memory.
#! - For new accounts, signaled by having a INITIAL_ACCOUNT_COMMITMENT set to EMPTY_WORD as a global
#!   input, validate the account's id and initial state.
#! - For existing accounts, verify the INITIAL_ACCOUNT_COMMITMENT commitment matches the provided data,
#!   and the account nonce is not zero.
#!
#! Inputs:
#!   Operand stack: []
#!   Advice stack: [
#!     account_id_suffix, account_id_prefix, 0, account_nonce,
#!     ACCOUNT_VAULT_ROOT,
#!     ACCOUNT_STORAGE_COMMITMENT,
#!     ACCOUNT_CODE_COMMITMENT
#!   ]
#! Outputs:
#!   Operand stack: []
#!   Advice stack: []
#!
#! Where:
#! - account_id_{prefix,suffix} are the prefix and suffix felts of the ID of the account that the
#!   transaction is being executed against.
#! - account_nonce is the account's nonce.
#! - ACCOUNT_VAULT_ROOT is the account's vault root.
#! - ACCOUNT_STORAGE_COMMITMENT is the account's storage commitment.
#! - ACCOUNT_CODE_COMMITMENT is the account's code commitment.
proc.process_account_data
    # Initialize the current account data pointer in the bookkeeping section with the native offset
    # (2048)
    exec.memory::set_current_account_data_ptr_to_native_account

    # Copy the account data from the advice provider to memory and hash it
    # ---------------------------------------------------------------------------------------------

    exec.memory::get_current_account_data_ptr
    # => [acct_data_ptr]

    # read account details and compute its digest. See `Advice stack` above for details.
    padw padw padw
    adv_pipe hperm
    adv_pipe hperm
    exec.rpo::squeeze_digest
    # => [ACCOUNT_COMMITMENT, acct_data_ptr']

    movup.4 drop
    # => [ACCOUNT_COMMITMENT]

    # assert the account ID matches the account ID in global inputs
    exec.memory::get_global_acct_id
    exec.memory::get_account_id
    exec.account::is_id_equal assert.err=ERR_PROLOGUE_MISMATCH_OF_ACCOUNT_IDS_FROM_GLOBAL_INPUTS_AND_ADVICE_PROVIDER
    # => [ACCOUNT_COMMITMENT]

    # store a copy of the initial nonce in global inputs
    exec.memory::get_acct_nonce
    exec.memory::set_init_nonce
    # => [ACCOUNT_COMMITMENT]

    # validates and stores account storage slots in memory.
    exec.memory::get_acct_storage_commitment
    exec.account::save_account_storage_data
    # => [ACCOUNT_COMMITMENT]

    # set the new account code commitment to the initial account code root
    # this is used for managing code commitment updates
    exec.memory::get_acct_code_commitment
    exec.memory::set_new_acct_code_commitment
    # => [ACCOUNT_CODE_COMMITMENT, ACCOUNT_COMMITMENT]

    # validates and stores account procedures in memory.
    exec.account::save_account_procedure_data
    # => [ACCOUNT_COMMITMENT]

    # copy the initial account vault hash to the input vault hash to support transaction asset
    # invariant checking
    exec.memory::get_acct_vault_root exec.memory::set_input_vault_root dropw
    # => [ACCOUNT_COMMITMENT]

    # Validate the account
    # ---------------------------------------------------------------------------------------------

    # It is a new account if the global input INITIAL_ACCOUNT_COMMITMENT was set to EMPTY_WORD.
    padw exec.memory::get_init_account_commitment eqw
    # => [is_new, INITIAL_ACCOUNT_COMMITMENT, EMPTY_WORD, ACCOUNT_COMMITMENT]

    # clean the stack
    movdn.8 dropw dropw
    # => [is_new, ACCOUNT_COMMITMENT]

    # process conditional logic depending on whether the account is new or existing
    if.true
        # set the initial account commitment
        exec.memory::set_init_account_commitment dropw
        # => []

        # validate the new account
        exec.validate_new_account
        # => []
    else
        # assert that the existing account commitment matches the hash in global inputs
        exec.memory::get_init_account_commitment
        assert_eqw.err=ERR_PROLOGUE_PROVIDED_ACCOUNT_DATA_DOES_NOT_MATCH_ON_CHAIN_COMMITMENT
        # => []

        # assert the nonce of an existing account is non-zero
        exec.memory::get_acct_nonce neq.0
        assert.err=ERR_PROLOGUE_EXISTING_ACCOUNT_MUST_HAVE_NON_ZERO_NONCE
        # => []
    end
end

# INPUT NOTES DATA
# =================================================================================================

#! Authenticates the input note data.
#!
#! This procedure will:
#! - authenticate the MMR leaf associated with the block the note was created in.
#! - authenticate the note root associated with the block the note was created in.
#! - authenticate the note and its metadata in the note Merkle tree from the block the note was
#!   created in.
#!
#! Inputs:
#!   Operand stack: [NOTE_COMMITMENT]
#!   Advice stack: [block_num, BLOCK_SUB_COMMITMENT, NOTE_ROOT, note_index]
#! Outputs:
#!   Operand stack: []
#!   Advice stack: []
#!
#! Where:
#! - NOTE_COMMITMENT is the input note's commitment computed as `hash(NOTE_ID || NOTE_METADATA)`.
#! - block_num is the leaf position in the MMR chain of the block which created the input note.
#! - BLOCK_SUB_COMMITMENT is the sub_commitment of the block which created the input note.
#! - NOTE_ROOT is the merkle root of the notes tree containing the input note.
#! - note_index is the input note's position in the notes tree.
proc.authenticate_note.8
    # Load the BLOCK_COMMITMENT from the PARTIAL_BLOCKCHAIN
    # ---------------------------------------------------------------------------------------------

    exec.memory::get_partial_blockchain_ptr adv_push.1
    # => [block_num, partial_blockchain_ptr, NOTE_COMMITMENT]

    exec.mmr::get
    # => [BLOCK_COMMITMENT, NOTE_COMMITMENT]

    locaddr.0
    # => [mem_ptr, BLOCK_COMMITMENT, NOTE_COMMITMENT]

    # Load and authenticate the NOTE_ROOT
    # ---------------------------------------------------------------------------------------------

    # read data from advice and compute hash(BLOCK_SUB_COMMITMENT || NOTE_ROOT)
    padw padw padw
    adv_pipe hperm
    # => [PERM, COMPUTED_BLOCK_COMMITMENT, PERM, mem_ptr', BLOCK_COMMITMENT, NOTE_COMMITMENT]

    dropw
    # => [COMPUTED_BLOCK_COMMITMENT, PERM, mem_ptr', BLOCK_COMMITMENT, NOTE_COMMITMENT]

    # assert the computed block commitment matches
    movup.8 drop movupw.2
    assert_eqw.err=ERR_PROLOGUE_MISMATCH_OF_REFERENCE_BLOCK_MMR_AND_NOTE_AUTHENTICATION_MMR
    # => [PERM, NOTE_COMMITMENT]

    # Authenticate the NOTE_COMMITMENT
    # ---------------------------------------------------------------------------------------------

    # load the note root from memory
    loc_loadw.4 swapw
    # => [NOTE_COMMITMENT, NOTE_ROOT]

    # load the index of the note
    adv_push.1 movdn.4
    # => [NOTE_COMMITMENT, note_index, NOTE_ROOT]

    # get the depth of the note tree
    exec.constants::get_note_tree_depth movdn.4
    # => [NOTE_COMMITMENT, depth, note_index, NOTE_ROOT]

    # verify the note commitment
    mtree_verify
    # => [NOTE_COMMITMENT, depth, note_index, NOTE_ROOT]

    dropw drop drop dropw
    # => []
end

#! Copies the input note's details from the advice stack to memory and computes its nullifier.
#!
#! Inputs:
#!   Operand stack: [note_ptr]
#!   Advice stack: [
#!      SERIAL_NUMBER,
#!      SCRIPT_ROOT,
#!      INPUTS_COMMITMENT,
#!      ASSETS_HASH,
#!   ]
#! Outputs:
#!   Operand stack: [NULLIFIER]
#!   Advice stack: []
#!
#! Where:
#! - note_ptr is the memory location for the input note.
#! - SERIAL_NUMBER is the note's serial.
#! - SCRIPT_ROOT is the note's script root.
#! - INPUTS_COMMITMENT is the sequential hash of the padded note's inputs.
#! - ASSETS_HASH is the sequential hash of the padded note's assets.
#! - NULLIFIER is the result of `hash(SERIAL_NUMBER || SCRIPT_ROOT || INPUTS_COMMITMENT || ASSETS_HASH)`.
proc.process_input_note_details
    exec.memory::get_input_note_core_ptr
    # => [note_data_ptr]

    # read input note's data and compute its digest. See `Advice stack` above for details.
    padw padw padw
    adv_pipe hperm
    adv_pipe hperm
    exec.rpo::squeeze_digest
    # => [NULLIFIER, note_data_ptr + 16]

    movup.4 drop
    # => [NULLIFIER]
end

#! Copies the note's metadata and args from the advice stack to memory.
#!
#! Notes:
#! - The note's ARGS are not authenticated, these are optional arguments the user can provide when
#!   consuming the note.
#! - The note's metadata is authenticated, so the data is returned in the stack. The value is used
#!   to compute the NOTE_COMMITMENT as `hash(NOTE_ID || NOTE_METADATA)`, which is the leaf value of the
#!   note's tree in the contained in the block header. The NOTE_COMMITMENT is either verified by this
#!   kernel, or delayed to be verified by another kernel (e.g. block or batch kernels).
#!
#! Inputs:
#!   Operand stack: [note_ptr]
#!   Advice stack: [NOTE_ARGS, NOTE_METADATA]
#! Outputs:
#!   Operand stack: [NOTE_METADATA]
#!   Advice stack: []
#!
#! Where:
#! - note_ptr is the memory location for the input note.
#! - NOTE_ARGS are the user arguments passed to the note.
#! - NOTE_METADATA is the note's metadata.
proc.process_note_args_and_metadata
    padw adv_loadw dup.4 exec.memory::set_input_note_args dropw
    # => [note_ptr]

    padw adv_loadw movup.4 exec.memory::set_input_note_metadata
    # => [NOTE_METADATA]
end

#! Checks that the number of note inputs is within limit and stores it to memory.
#!
#! Inputs:
#!   Operand stack: [note_ptr]
#!   Advice stack: [inputs_len]
#! Outputs:
#!   Operand stack: [note_ptr]
#!   Advice stack: []
#!
#! Where:
#! - note_ptr is the memory location for the input note.
#! - inputs_len is the note's input count.
proc.process_note_inputs_length
    # move the inputs length from the advice stack to the operand stack
    adv_push.1
    # => [inputs_len, note_ptr]

    # validate the input length
    dup exec.::kernel::util::note::get_max_inputs_per_note lte
    assert.err=ERR_PROLOGUE_NUMBER_OF_NOTE_INPUTS_EXCEEDED_LIMIT
    # => [inputs_len, note_ptr]

    # store the inputs length into the memory
    dup.1 exec.memory::set_input_note_num_inputs
    # => [note_ptr]
end

#! Copies the note's assets from the advice stack to memory and verifies the commitment.
#!
#! Inputs:
#!   Operand stack: [note_ptr]
#!   Advice stack: [assets_count, ASSET_0, ..., ASSET_N]
#! Outputs:
#!   Operand stack: []
#!   Advice stack: []
#!
#! Where:
#! - note_ptr is the memory location for the input note.
#! - assets_count is the note's assets count.
#! - ASSET_0, ..., ASSET_N are the padded note's assets.
proc.process_note_assets
    # verify and save the assets count
    # ---------------------------------------------------------------------------------------------

    adv_push.1
    # => [assets_count, note_ptr]

    dup exec.constants::get_max_assets_per_note lte
    assert.err=ERR_PROLOGUE_NUMBER_OF_NOTE_ASSETS_EXCEEDS_LIMIT
    # => [assets_count, note_ptr]

    dup dup.2 exec.memory::set_input_note_num_assets
    # => [assets_count, note_ptr]

    # round up the number of assets, to the its padded length
    dup push.1 u32and add
    # => [rounded_num_assets, note_ptr]

    # read the note's assets
    # ---------------------------------------------------------------------------------------------

    # Stack organization:
    # - Top of the stack contains the hash state. The complete state is needed to extract the final
    #   hash.
    # - Followed by the assets_ptr, with the target address used to pipe data from the advice
    #   provider.
    # - Followed by a copy of the note_ptr for later use.
    # - Followed by the loop variables, the current counter and rounded_num_assets, laid at this
    #   depth because dup.15 is an efficient operation.

    push.0 movup.2
    # => [note_ptr, counter, rounded_num_assets]

    dup exec.memory::get_input_note_assets_ptr
    # => [assets_ptr, note_ptr, counter, rounded_num_assets]

    padw padw padw
    # => [PERM, PERM, PERM, assets_ptr, note_ptr, counter, rounded_num_assets]

    # loop condition: counter != rounded_num_assets
    dup.15 dup.15 neq
    # => [should_loop, PERM, PERM, PERM, assets_ptr, note_ptr, counter, rounded_num_assets]

    # loop and read assets from the advice provider
    while.true
        # read data and compute its digest. See `Advice stack` above for details.
        adv_pipe hperm
        # => [PERM, PERM, PERM, assets_ptr+8, note_ptr, counter, rounded_num_assets]

        # update counter
        swapw.3 movup.2 add.2 movdn.2 swapw.3
        # => [PERM, PERM, PERM, assets_ptr+8, note_ptr, counter+2, rounded_num_assets]

        # loop condition: counter != rounded_num_assets
        dup.15 dup.15 neq
        # => [should_loop, PERM, PERM, PERM, assets_ptr+8, note_ptr, counter+2, rounded_num_assets]
    end
    # => [PERM, PERM, PERM, assets_ptr+8n, note_ptr, counter+2n, rounded_num_assets]

    exec.rpo::squeeze_digest
    # => [ASSET_COMMITMENT_COMPUTED, assets_ptr+8n, note_ptr, counter+2n, rounded_num_assets]

    swapw drop movdn.2 drop drop
    # => [note_ptr, ASSET_COMMITMENT_COMPUTED]

    # VERIFY: computed ASSET_COMMITMENT matches the provided hash
    exec.memory::get_input_note_assets_hash
    assert_eqw.err=ERR_PROLOGUE_PROVIDED_INPUT_ASSETS_INFO_DOES_NOT_MATCH_ITS_COMMITMENT
    # => []
end

#! Adds the assets of an input note to the input vault.
#!
#! Inputs:  [note_ptr]
#! Outputs: []
#!
#! Where:
#! - note_ptr is the memory location for the input note.
proc.add_input_note_assets_to_vault
    # prepare the stack
    # ---------------------------------------------------------------------------------------------

    exec.memory::get_input_vault_root_ptr
    # => [input_vault_root_ptr, note_ptr]

    dup.1 exec.memory::get_input_note_assets_ptr
    # => [assets_start_ptr, input_vault_root_ptr, note_ptr]

    dup movup.3 exec.memory::get_input_note_num_assets mul.4 add swap
    # => [assets_start_ptr, assets_end_ptr, input_vault_root_ptr]

    # add input note's assets to input vault
    # ---------------------------------------------------------------------------------------------

    # loop condition: assets_start_ptr != assets_end_ptr
    dup.1 dup.1 neq
    # => [should_loop, assets_start_ptr, assets_end_ptr, input_vault_root_ptr]

    while.true
        dup.2
        # => [input_vault_root_ptr, assets_start_ptr, assets_end_ptr, input_vault_root_ptr]

        padw dup.5 mem_loadw
        # => [ASSET, input_vault_root_ptr, assets_start_ptr, assets_end_ptr, input_vault_root_ptr]

        exec.asset_vault::add_asset dropw
        # => [assets_start_ptr, assets_end_ptr, input_vault_root_ptr]

        add.4
        # => [assets_start_ptr+4, assets_end_ptr, input_vault_root_ptr]

        # loop condition: assets_start_ptr != assets_end_ptr
        dup.1 dup.1 neq
        # => [should_loop, assets_start_ptr+4, assets_end_ptr, input_vault_root_ptr]
    end

    drop drop drop
    # => []
end

#! Computes an input note's id.
#!
#! Inputs:  [note_ptr]
#! Outputs: [NOTE_ID]
#!
#! Where:
#! - note_ptr is the memory location for the input note.
#! - NOTE_ID is the note's id, i.e. `hash(RECIPIENT || ASSET_COMMITMENT)`.
proc.compute_input_note_id
    # compute SERIAL_HASH: hash(SERIAL_NUMBER || EMPTY_WORD)
    dup exec.memory::get_input_note_serial_num padw hmerge
    # => [SERIAL_HASH, note_ptr]

    # compute MERGE_SCRIPT: hash(SERIAL_HASH || SCRIPT_ROOT)
    dup.4 exec.memory::get_input_note_script_root hmerge
    # => [MERGE_SCRIPT, note_ptr]

    # compute RECIPIENT: hash(MERGE_SCRIPT || INPUT_COMMITMENT)
    dup.4 exec.memory::get_input_note_inputs_commitment hmerge
    # => [RECIPIENT, note_ptr]

    # compute NOTE_ID: hash(RECIPIENT || ASSET_COMMITMENT)
    movup.4 exec.memory::get_input_note_assets_hash hmerge
    # => [NOTE_ID]
end

#! Reads data for the input note from the advice provider and stores it in memory at the appropriate
#! memory address.
#!
#! This procedures will also compute the note's nullifier. Store the note's nullifier, metadata,
#! args, assets, id, and hash to memory. And return the hasher state in the stack so that the
#! commitment can be extracted.
#!
#! Inputs:
#!   Operand stack: [idx, HASHER_CAPACITY]
#!   Advice stack: [
#!      SERIAL_NUMBER,
#!      SCRIPT_ROOT,
#!      INPUTS_COMMITMENT,
#!      ASSETS_HASH,
#!      ARGS,
#!      NOTE_METADATA,
#!      assets_count,
#!      ASSET_0, ..., ASSET_N,
#!      is_authenticated,
#!      (
#!        block_num,
#!        BLOCK_SUB_COMMITMENT,
#!        NOTE_ROOT,
#!      )?
#!   ]
#! Outputs:
#!   Operand stack: [PERM, PERM, PERM]
#!   Advice stack: []
#!
#! Where:
#! - idx is the index of the input note.
#! - HASHER_CAPACITY is the state of the hasher capacity word, with the commitment to the previous
#!   notes.
#! - SERIAL_NUMBER is the note's serial.
#! - SCRIPT_ROOT is the note's script root.
#! - INPUTS_COMMITMENT is the sequential hash of the padded note's inputs.
#! - ASSETS_HASH is the sequential hash of the padded note's assets.
#! - NOTE_METADATA is the note's metadata.
#! - ARGS is the user arguments passed to the note.
#! - assets_count is the note's assets count.
#! - ASSET_0, ..., ASSET_N are the padded note's assets.
#! - is_authenticated is the boolean indicating if the note contains an authentication proof.
#! - optional values, required if `is_authenticated` is true:
#!   - block_num is the note's creation block number.
#!   - BLOCK_SUB_COMMITMENT is the block's sub_commitment for which the note was created.
#!   - NOTE_ROOT is the merkle root of the note's tree.
proc.process_input_note
    # note details
    # ---------------------------------------------------------------------------------------------

    dup exec.memory::get_input_note_ptr dup
    # => [note_ptr, note_ptr, idx, HASHER_CAPACITY]

    exec.process_input_note_details
    # => [NULLIFIER, note_ptr, idx, HASHER_CAPACITY]

    # save NULLIFIER to memory
    movup.5 exec.memory::get_input_note_nullifier_ptr mem_storew
    # => [NULLIFIER, note_ptr, HASHER_CAPACITY]

    # note metadata & args
    # ---------------------------------------------------------------------------------------------

    movup.4
    # => [note_ptr, NULLIFIER, HASHER_CAPACITY]

    dup exec.process_note_args_and_metadata
    # => [NOTE_METADATA, note_ptr, NULLIFIER, HASHER_CAPACITY]

    movup.4
    # => [note_ptr, NOTE_METADATA, NULLIFIER, HASHER_CAPACITY]

    # note inputs len
    # ---------------------------------------------------------------------------------------------

    exec.process_note_inputs_length
    # => [note_ptr, NOTE_METADATA, NULLIFIER, HASHER_CAPACITY]

    # note assets
    # ---------------------------------------------------------------------------------------------

    dup exec.process_note_assets
    dup exec.add_input_note_assets_to_vault
    # => [note_ptr, NOTE_METADATA, NULLIFIER, HASHER_CAPACITY]

    # note id
    # ---------------------------------------------------------------------------------------------

    dup exec.compute_input_note_id
    # => [NOTE_ID, note_ptr, NOTE_METADATA, NULLIFIER, HASHER_CAPACITY]

    # save note id to memory
    movup.4 exec.memory::set_input_note_id
    # => [NOTE_ID, NOTE_METADATA, NULLIFIER, HASHER_CAPACITY]

    # note authentication
    # ---------------------------------------------------------------------------------------------

    # NOTE_COMMITMENT: `hash(NOTE_ID || NOTE_METADATA)`
    swapw hmerge
    # => [NOTE_COMMITMENT, NULLIFIER, HASHER_CAPACITY]

    adv_push.1
    # => [is_authenticated, NOTE_COMMITMENT, NULLIFIER, HASHER_CAPACITY]

    if.true
        # => [NOTE_COMMITMENT, NULLIFIER, HASHER_CAPACITY]

        exec.authenticate_note
        # => [NULLIFIER, HASHER_CAPACITY]

        padw
        # => [EMPTY_WORD, NULLIFIER, HASHER_CAPACITY]
    end
    # => [EMPTY_WORD_OR_NOTE_COMMITMENT, NULLIFIER, HASHER_CAPACITY]

    # update the input note commitment
    hperm
    # => [PERM, PERM, PERM]
end

#! Process the input notes data provided via the advice provider. This involves reading the data
#! from the advice provider and storing it at the appropriate memory addresses. As each note is
#! processed its hash and nullifier are computed. The transaction input notes commitment is
#! computed via a sequential hash of all (NULLIFIER, EMPTY_WORD_NOTE_COMMITMENT) pairs for all input
#! notes.
#!
#! Inputs:
#!   Operand stack: []
#!   Advice stack: [num_notes],
#!   Advice map: {
#!     INPUT_NOTES_COMMITMENT: [NOTE_DATA]
#!   }
#! Outputs:
#!   Operand stack: []
#!   Advice stack: []
#!
#! Where:
#! - num_notes is the number of input notes.
#! - INPUT_NOTES_COMMITMENT, see `transaction::api::get_input_notes_commitment`.
#! - NOTE_DATA is the input notes' details, for format see `prologue::process_input_note`.
proc.process_input_notes_data
    # get the number of input notes from the advice stack
    adv_push.1
    # => [num_notes]

    # assert the number of input notes is within limits; since max number of input notes is
    # expected to be smaller than 2^32, we can use a more efficient u32 comparison
    dup
    exec.constants::get_max_num_input_notes
    u32assert2.err=ERR_PROLOGUE_NUMBER_OF_INPUT_NOTES_EXCEEDS_LIMIT
    u32lte assert.err=ERR_PROLOGUE_NUMBER_OF_INPUT_NOTES_EXCEEDS_LIMIT
    # => [num_notes]

    # if there are input notes, load input notes data from the advice map onto the advice stack
    dup neq.0
    if.true
        exec.memory::get_input_notes_commitment
        adv.push_mapval
        dropw
    end
    # => [num_notes]

    # store the number of input notes into kernel memory
    dup exec.memory::set_num_input_notes
    # => [num_notes]

    # loop over input notes and read data
    # ---------------------------------------------------------------------------------------------

    # Stack organization:
    # - On the top of the stack is the hasher state containing the input notes commitment. The
    #   hasher state will be updated by `process_input_note`. After the loop the commitment is
    #   extracted.
    # - Below the hasher state in the stack is the current note index. This number is used for two
    #   purposes:
    #   1. Compute the input note's memory addresses, the index works as an offset.
    #   2. Determine the loop condition. The loop below runs until all input notes have been
    #      processed.
    # - The num_notes is kept at position 13, because dup.13 is cheap.
    # - The [idx, num_notes] pair is kept in a word boundary, so that its word can be swapped with a
    #   cheap swapw.3 instruction to update the `idx` counter.

    push.0 padw padw padw
    # => [PERM, PERM, PERM, idx, num_notes]

    # loop condition: idx != num_notes
    dup.13 dup.13 neq
    # => [has_more_notes, PERM, PERM, PERM, idx, num_notes]

    while.true
        # the hasher operates in overwrite mode, so discard the rate words, and keep the capacity
        dropw dropw
        # => [HASHER_CAPACITY, idx, num_notes]

        # process the note
        dup.4 exec.process_input_note
        # => [PERM, PERM, PERM, idx, num_notes]

        # update the idx counter
        swapw.3 add.1 swapw.3
        # => [PERM, PERM, PERM, idx+1, num_notes]

        # loop condition: idx != num_notes
        dup.13 dup.13 neq
        # => [has_more_notes, PERM, PERM, PERM, idx+1, num_notes]
    end

    exec.rpo::squeeze_digest
    # => [INPUT_NOTES_COMMITMENT, idx+1, num_notes]

    # assert the input notes and the commitment matches
    exec.memory::get_input_notes_commitment
    assert_eqw.err=ERR_PROLOGUE_INPUT_NOTES_COMMITMENT_MISMATCH
    # => [idx+1, num_notes]

    # set the current input note ptr to the address of the first input note
    push.0
    exec.memory::get_input_note_ptr
    exec.memory::set_current_input_note_ptr
    # => [idx+1, num_notes]

    drop drop
    # => []
end

# TRANSACTION SCRIPT
# =================================================================================================

#! Saves the transaction script root to memory.
#!
#! Inputs:
#!   Operand stack: []
#!   Advice stack: [TX_SCRIPT_ROOT]
#! Outputs:
#!   Operand stack: []
#!   Advice stack: []
#!
#! Where:
#! - TX_SCRIPT_ROOT is the transaction's script root.
proc.process_tx_script_root
    # read the transaction script root from the advice stack
    adv_loadw
    # => [TX_SCRIPT_ROOT]

    # store the transaction script root in memory
    exec.memory::set_tx_script_root dropw
    # => []
end

# TRANSACTION PROLOGUE
# =================================================================================================

#! The transaction prologue is executed at the beginning of a transaction. Its responsibility is:
#! 1. "Unhash" inputs, authenticate the data and store it in the root contexts memory.
#! 2. Build a single vault containing assets of all inputs (input notes combined with current
#!    account vault).
#! 3. Verify that all input notes are present in the note db.
#!
#! Inputs:
#!   Operand stack: [
#!     BLOCK_COMMITMENT,
#!     INITIAL_ACCOUNT_COMMITMENT,
#!     INPUT_NOTES_COMMITMENT,
#!     account_id_prefix, account_id_suffix, block_num,
#!   ]
#!   Advice stack: [
#!     PREV_BLOCK_COMMITMENT,
#!     PARTIAL_BLOCKCHAIN_COMMITMENT,
#!     ACCOUNT_ROOT,
#!     NULLIFIER_ROOT,
#!     TX_COMMITMENT,
#!     TX_KERNEL_COMMITMENT
#!     PROOF_COMMITMENT,
#!     [block_num, version, timestamp, 0],
#!     NOTE_ROOT,
#!     kernel_version
#!     [account_id_suffix, account_id_prefix, 0, account_nonce],
#!     ACCOUNT_VAULT_ROOT,
#!     ACCOUNT_STORAGE_COMMITMENT,
#!     ACCOUNT_CODE_COMMITMENT,
#!     number_of_input_notes,
#!     TX_SCRIPT_ROOT,
#!   ]
#!   Advice map: {
#!      PARTIAL_BLOCKCHAIN_COMMITMENT: [MMR_PEAKS],
#!      INPUT_NOTES_COMMITMENT: [NOTE_DATA],
#!      TX_KERNEL_COMMITMENT: [KERNEL_COMMITMENTS],
#!      KERNEL_COMMITMENT: [KERNEL_PROCEDURE_ROOTS],
#!      ACCOUNT_CODE_COMMITMENT: [ACCOUNT_PROCEDURE_DATA],
#!      ACCOUNT_STORAGE_COMMITMENT: [ACCOUNT_STORAGE_SLOT_DATA],
#!   }
#! Outputs:
#!   Operand stack: []
#!   Advice stack: []
#!
#! Where:
#! - BLOCK_COMMITMENT is the commitment to the reference block of the transaction.
#! - account_id_{prefix,suffix} are the prefix and suffix felts of the account that the transaction
#!   is being executed against.
#! - INITIAL_ACCOUNT_COMMITMENT is the account state prior to the transaction, EMPTY_WORD for new
#!   accounts.
#! - INPUT_NOTES_COMMITMENT, see `transaction::api::get_input_notes_commitment`.
#! - TX_KERNEL_COMMITMENT is the accumulative hash from all kernel commitments.
#! - PREV_BLOCK_COMMITMENT is the commitment to the previous block.
#! - PARTIAL_BLOCKCHAIN_COMMITMENT is the sequential hash of the reference MMR.
#! - ACCOUNT_ROOT is the root of the tree with latest account states for all accounts.
#! - NULLIFIER_ROOT is the root of the tree with nullifiers of all notes that have ever been
#!   consumed.
#! - TX_COMMITMENT is a commitment to the set of transaction IDs which affected accounts in the block.
#! - PROOF_COMMITMENT is the commitment of the block's STARK proof attesting to the correct state transition.
#! - block_num is the reference block number.
#! - version is the current protocol version.
#! - timestamp is the current timestamp.
#! - NOTE_ROOT is the root of the tree with all notes created in the block.
#! - kernel_version is the index of the desired kernel in the array of all kernels available for the
#!   current transaction.
#! - account_nonce is the account's nonce.
#! - ACCOUNT_VAULT_ROOT is the account's vault root.
#! - ACCOUNT_STORAGE_COMMITMENT is the account's storage commitment.
#! - ACCOUNT_CODE_COMMITMENT is the account's code commitment.
#! - ACCOUNT_PROCEDURE_DATA is the vector of the account's procedure data.
#! - ACCOUNT_STORAGE_SLOT_DATA is the vector of the account's storage slot data.
#! - number_of_input_notes is the number of input notes.
#! - TX_SCRIPT_ROOT is the transaction's script root.
#! - MMR_PEAKS is the MMR peak data, see process_chain_data.
#! - NOTE_DATA is the input notes' details, for format see prologue::process_input_note.
#!
#! Panics if:
#! - data provided by the advice provider does not match global inputs.
#! - the account data is invalid.
#! - any of the input notes do note exist in the note db.
export.prepare_transaction
    exec.process_global_inputs
    # => [block_num]

    exec.process_block_data
    exec.process_kernel_data
    exec.process_chain_data
    exec.process_account_data
    exec.process_input_notes_data
    exec.process_tx_script_root
    # => []

    push.MAX_BLOCK_NUM exec.memory::set_expiration_block_num
end
