use.miden::account
use.miden::kernel_proc_offsets

#Â ERRORS
# =================================================================================================

# Failed to build the fungible asset because the provided faucet id is not from a fungible faucet
const.ERR_FUNGIBLE_ASSET_PROVIDED_FAUCET_ID_IS_INVALID=0x00020206

# Fungible asset build operation called with amount that exceeds the maximum allowed asset amount
const.ERR_FUNGIBLE_ASSET_AMOUNT_EXCEEDS_MAX_ALLOWED_AMOUNT=0x00020200

# Failed to build the non-fungible asset because the provided faucet id is not from a non-fungible faucet
const.ERR_NON_FUNGIBLE_ASSET_PROVIDED_FAUCET_ID_IS_INVALID=0x00020244

# PROCEDURES
# =================================================================================================

#! Builds a fungible asset for the specified fungible faucet and amount.
#!
#! Inputs:  [faucet_id_prefix, faucet_id_suffix, amount]
#! Outputs: [ASSET]
#!
#! Where:
#! - faucet_id_{prefix,suffix} are the prefix and suffix felts of the faucet to create the asset
#!   for.
#! - amount is the amount of the asset to create.
#! - ASSET is the built fungible asset.
#!
#! Annotation hint: is not used anywhere except this file
export.build_fungible_asset
    # assert the faucet is a fungible faucet
    dup exec.account::is_fungible_faucet assert.err=ERR_FUNGIBLE_ASSET_PROVIDED_FAUCET_ID_IS_INVALID
    # => [faucet_id_prefix, faucet_id_suffix, amount]

    # assert the amount is valid
    dup.2 exec.get_fungible_asset_max_amount lte
    assert.err=ERR_FUNGIBLE_ASSET_AMOUNT_EXCEEDS_MAX_ALLOWED_AMOUNT
    # => [faucet_id_prefix, faucet_id_suffix, amount]

    # create the asset
    push.0 movdn.2
    # => [ASSET]
end

#! Creates a fungible asset for the faucet the transaction is being executed against.
#!
#! Inputs:  [amount]
#! Outputs: [ASSET]
#!
#! Where:
#! - amount is the amount of the asset to create.
#! - ASSET is the created fungible asset.
#!
#! Invocation: exec
export.create_fungible_asset
    # fetch the id of the faucet the transaction is being executed against.
    exec.account::get_id
    # => [id_prefix, id_suffix, amount]

    # build the fungible asset
    exec.build_fungible_asset
    # => [ASSET]
end

#! Builds a non fungible asset for the specified non-fungible faucet and amount.
#!
#! Inputs:  [faucet_id_prefix, DATA_HASH]
#! Outputs: [ASSET]
#!
#! Where:
#! - faucet_id_{prefix,suffix} are the prefix and suffix felts of the faucet to create the asset
#!   for.
#! - DATA_HASH is the data hash of the non-fungible asset to build.
#! - ASSET is the built non-fungible asset.
#!
#! Annotation hint: is not used anywhere except this file
export.build_non_fungible_asset
    # assert the faucet is a non-fungible faucet
    dup exec.account::is_non_fungible_faucet
    assert.err=ERR_NON_FUNGIBLE_ASSET_PROVIDED_FAUCET_ID_IS_INVALID
    # => [faucet_id_prefix, hash3, hash2, hash1, hash0]

    # build the asset
    swap drop
    # => [faucet_id_prefix, hash2, hash1, hash0]
    # => [ASSET]
end

#! Creates a non-fungible asset for the faucet the transaction is being executed against.
#!
#! Inputs:  [DATA_HASH]
#! Outputs: [ASSET]
#!
#! Where:
#! - DATA_HASH is the data hash of the non-fungible asset to create.
#! - ASSET is the created non-fungible asset.
#!
#! Invocation: exec
export.create_non_fungible_asset
    # get the id of the faucet the transaction is being executed against
    exec.account::get_id swap drop
    # => [faucet_id_prefix, DATA_HASH]

    # build the non-fungible asset
    exec.build_non_fungible_asset
    # => [ASSET]
end

#! Returns the maximum amount of a fungible asset.
#!
#! Stack: []
#! Outputs: [fungible_asset_max_amount]
#!
#! fungible_asset_max_amount is the maximum amount of a fungible asset.
export.::miden::util::asset::get_fungible_asset_max_amount

#! Creates a new asset with the given number of fields and returns the pointer to it.
#!
#! Inputs:  [num_fields, type_id]
#! Outputs: [asset_ptr]
export.create
    exec.kernel_proc_offsets::asset_create_offset
    # => [offset, num_fields, type_id]

    # Padding Ops:
    # => [offset, num_fields, type_id, 0]
    # => [pad(4), pad(4), offset, num_fields, type_id, 0]
    # => [pad(4), pad(4), pad(4), offset, num_fields, type_id, 0]
    # => [pad(4), offset, num_fields, type_id, 0, pad(4), pad(4)]
    # => [offset, num_fields, type_id, 0, pad(4), pad(4), pad(4)]

    # pad the stack
    push.0 movdn.3 padw padw padw swapdw swapw
    # => [offset, num_fields, type_id, pad(13)]

    syscall.exec_kernel_proc
    # => [asset_ptr, pad(15)]

    # clean the stack
    swapdw dropw dropw
    # => [asset_ptr, pad(7)]
    swapw dropw
    # => [asset_ptr, 0, 0, 0]
    movdn.3 drop drop drop

    # => [asset_ptr]
end

#! Destroys the given asset by making it inaccessible by invalidating its ptr.
#!
#! Inputs:  [asset_ptr]
#! Outputs: []
export.destroy
  exec.kernel_proc_offsets::asset_destroy_offset
  # => [offset, asset_ptr]

  repeat.14 push.0 movdn.2 end
  # => [offset, asset_ptr, pad(14)]

  syscall.exec_kernel_proc
  # => [pad(16)]

  dropw dropw dropw dropw
  # => []
end

#! Creates a new one time witness in the context of the native account if it has not been created before.
#!
#! Inputs:  [one_time_witness_id]
#! Outputs: []
export.consume_one_time_witness
  exec.kernel_proc_offsets::asset_consume_one_time_witness_offset
  # => [offset, one_time_witness_id]

  # pad the stack
  push.0.0 movdn.3 movdn.3 padw padw padw swapdw swapw
  # => [offset, one_time_witness_id, pad(14)]

  syscall.exec_kernel_proc
  # => [pad(16)]

  # clean the stack
  dropw dropw dropw dropw
  # => []
end

#! Gets the ID of the asset.
#!
#! Inputs:  [asset_ptr]
#! Outputs: [ASSET_ID]
export.get_id
  exec.kernel_proc_offsets::asset_get_id_offset
  # => [offset, asset_ptr]

  # pad the stack
  #push.0.0 movdn.3 movdn.3 padw swapw padw padw swapdw
  repeat.14 push.0 movdn.2 end
  # => [offset, asset_ptr, pad(14)]

  syscall.exec_kernel_proc
  # => [ASSET_ID, pad(12)]

  # clean the stack
  # swapdw dropw dropw swapw dropw swapw dropw
  repeat.12 movup.4 drop end
  # => [ASSET_ID]
end

#! Sets the field of the asset to the provided value.
#!
#! Inputs:  [asset_ptr, field_idx, field_value]
#! Outputs: []
export.set_field
  exec.kernel_proc_offsets::asset_set_field_offset
  # => [offset, asset_ptr, field_idx, field_value]

  # pad the stack
  padw padw padw swapdw swapw
  # => [offset, asset_ptr, field_idx, field_value, pad(12)]

  syscall.exec_kernel_proc
  # => [pad(16)]

  # clean the stack
  dropw dropw dropw dropw
  # => []
end

#! Gets the field of the asset.
#!
#! Inputs:  [asset_ptr, field_idx]
#! Outputs: [field_value]
export.get_field
  exec.kernel_proc_offsets::asset_get_field_offset
  # => [offset, asset_ptr, field_idx]

  # pad the stack
  push.0 movdn.3 padw padw padw swapdw swapw
  # => [offset, asset_ptr, field_idx, field_value, pad(13)]

  syscall.exec_kernel_proc
  # => [field_value, pad(15)]

  # clean the stack
  swapdw dropw dropw swapw dropw swap drop swap drop swap drop
  # => [field_value]
end

#! Stores the asset in kernel memory to the native account's vault.
#!
#! Inputs:  [asset_ptr]
#! Outputs: []
export.store_to_account
  exec.kernel_proc_offsets::asset_store_to_account_offset
  # => [offset, asset_ptr]

  # pad the stack
  # push.0.0 movdn.3 movdn.3 padw padw padw swapdw swapw
  repeat.14 push.0 movdn.2 end
  # => [offset, asset_ptr, pad(14)]

  syscall.exec_kernel_proc
  # => [pad(16)]

  # clean the stack
  dropw dropw dropw dropw
  # => []
end

#! Loads the asset from the native account's vault into kernel memory.
#! 
#! NOTE: Bypasses asset_vault.masm for now and does not emit events.
#!
#! Inputs:  [ASSET_ID, asset_type]
#! Outputs: [asset_ptr]
export.load_from_account
  exec.kernel_proc_offsets::asset_load_from_account
  # => [offset, ASSET_ID, asset_type]

  # pad the stack
  repeat.10 push.0 movdn.6 end
  # => [offset, ASSET_ID, asset_type, pad(10)]

  syscall.exec_kernel_proc
  # => [asset_ptr, pad(15)]

  # clean the stack
  repeat.15 swap drop end
  # => [asset_ptr]
end

#! Gets the issuer of an asset.
#!
#! Inputs:  [asset_ptr]
#! Outputs: [account_id_prefix, account_id_suffix]
export.asset_get_issuer
  exec.kernel_proc_offsets::asset_get_issuer_offset
  # => [offset, asset_ptr]

  # pad the stack
  push.0.0 movdn.3 movdn.3 padw padw padw swapdw swapw
  # => [offset, asset_ptr, pad(14)]

  syscall.exec_kernel_proc
  # => [account_id_prefix, account_id_suffix, pad(14)]

  # clean the stack
  swapdw dropw dropw swapw dropw movup.2 drop movup.2 drop
  # => [account_id_prefix, account_id_suffix]
end

#! Gets the type of an asset.
#!
#! Inputs:  [asset_ptr]
#! Outputs: [type_id]
export.asset_get_type
  exec.kernel_proc_offsets::asset_get_type_offset
  # => [offset, asset_ptr]

  # pad the stack
  push.0.0 movdn.3 movdn.3 padw padw padw swapdw swapw
  # => [offset, asset_ptr, pad(14)]

  syscall.exec_kernel_proc
  # => [type_id, pad(15)]

  # clean the stack
  swapdw dropw dropw swapw dropw swap drop swap drop swap drop
  # => [type_id]
end

#! Gets the number of fields of an asset.
#!
#! Inputs:  [asset_ptr]
#! Outputs: [num_fields]
export.asset_get_num_fields
  exec.kernel_proc_offsets::asset_get_num_fields_offset
  # => [offset, asset_ptr]

  # pad the stack
  push.0.0 movdn.3 movdn.3 padw padw padw swapdw swapw
  # => [offset, asset_ptr, pad(14)]

  syscall.exec_kernel_proc
  # => [num_fields, pad(15)]

  # clean the stack
  swapdw dropw dropw swapw dropw swap drop swap drop swap drop
  # => [num_fields]
end
