use.std::collections::mmr
use.std::collections::smt
use.std::crypto::hashes::rpo
use.std::mem

use.kernel::constants
use.kernel::memory

# ERRORS
# =================================================================================================

# Account nonce cannot be increased by a greater than u32 value
const.ERR_ACCOUNT_NONCE_INCREASE_MUST_BE_U32=0x00020004

# Least significant byte of second felt of the account id must be zero.
const.ERR_ACCOUNT_ID_LEAST_SIGNIFICANT_BYTE_MUST_BE_ZERO=0x00020005

# Account code must be updatable for it to be possible to set new code
const.ERR_ACCOUNT_CODE_IS_NOT_UPDATABLE=0x00020006

# Anchor block hash must not be empty
const.ERR_ACCOUNT_ANCHOR_BLOCK_HASH_MUST_NOT_BE_EMPTY=0x00020007

# ID of the new account does not match the ID computed from the seed and anchor block hash
const.ERR_ACCOUNT_SEED_ANCHOR_BLOCK_HASH_DIGEST_MISMATCH=0x00020008

# Failed to write an account value item to a non-value storage slot
const.ERR_ACCOUNT_SETTING_VALUE_ITEM_ON_NON_VALUE_SLOT=0x00020009

# Failed to write an account map item to a non-map storage slot
const.ERR_ACCOUNT_SETTING_MAP_ITEM_ON_NON_MAP_SLOT=0x0002000A

# Account procedure is not part of the account code
const.ERR_ACCOUNT_PROC_NOT_PART_OF_ACCOUNT_CODE=0x0002000B

# Provided procedure index is out of bounds
const.ERR_ACCOUNT_PROC_INDEX_OUT_OF_BOUNDS=0x0002000C

# Provided storage slot index is out of bounds
const.ERR_STORAGE_SLOT_INDEX_OUT_OF_BOUNDS=0x0002000D

# Storage offset is invalid for a faucet account (0 is prohibited as it is the reserved data slot for faucets)
const.ERR_FAUCET_INVALID_STORAGE_OFFSET=0x0002000E

# Computed account code commitment does not match recorded account code commitment
const.ERR_ACCOUNT_CODE_COMMITMENT_MISMATCH=0x0002000F

# Number of account procedures exceeds the maximum limit of 256
const.ERR_ACCOUNT_TOO_MANY_PROCEDURES=0x00020010

# Number of account storage slots exceeds the maximum limit of 255
const.ERR_ACCOUNT_TOO_MANY_STORAGE_SLOTS=0x00020011

# Computed account storage commitment does not match recorded account storage commitment
const.ERR_ACCOUNT_STORAGE_COMMITMENT_MISMATCH=0x00020012

# Storage offset is invalid for 0 storage size (should be 0)
const.ERR_ACCOUNT_INVALID_STORAGE_OFFSET_FOR_SIZE=0x00020013

# ID of the provided foreign account equals zero.
const.ERR_FOREIGN_ACCOUNT_ID_IS_ZERO=0x00020014

# Maximum allowed number of foreign account to be loaded (64) was exceeded.
const.ERR_FOREIGN_ACCOUNT_MAX_NUMBER_EXCEEDED=0x00020015

# Provided foreign account ID is equal to the native account ID. 
const.ERR_FOREIGN_ACCOUNT_ID_EQUALS_NATIVE_ACCT_ID=0x00020016

# State of the current foreign account is invalid.
const.ERR_FOREIGN_ACCOUNT_INVALID=0x00020017

# Unknown version in account id.
const.ERR_ACCOUNT_ID_UNKNOWN_VERSION=0x00020057

# Epoch must be less than u16::MAX (0xffff).
const.ERR_ACCOUNT_ID_EPOCH_MUST_BE_LESS_THAN_U16_MAX=0x00020058

# CONSTANTS
# =================================================================================================

# Given the least significant 32 bits of an account id's first felt, this mask defines the bits used
# to determine the account version.
const.ACCOUNT_VERSION_MASK_U32=0x0f # 0b1111

# Given the least significant 32 bits of an account id's first felt, this mask defines the bits used
# to determine the account type.
const.ACCOUNT_ID_TYPE_MASK_U32=0x30 # 0b11_0000

# Bit pattern for an account w/ immutable code, after the account type mask has been applied.
const.REGULAR_ACCOUNT_IMMUTABLE_CODE=0 # 0b00_0000

# Bit pattern for an account w/ updatable code, after the account type mask has been applied.
const.REGULAR_ACCOUNT_UPDATABLE_CODE=0x10 # 0b01_0000

# Bit pattern for a fungible faucet w/ immutable code, after the account type mask has been applied.
const.FUNGIBLE_FAUCET_ACCOUNT=0x20 # 0b10_0000

# Bit pattern for a non-fungible faucet w/ immutable code, after the account type mask has been 
# applied.
const.NON_FUNGIBLE_FAUCET_ACCOUNT=0x30 # 0b11_0000

# Bit pattern for a faucet account, after the account type mask has been applied.
const.FAUCET_ACCOUNT=0x20 # 0b10_0000

# The maximum number of account interface procedures.
const.MAX_NUM_PROCEDURES=256

# The account storage slot at which faucet data is stored.
# Fungible faucet: The faucet data consists of [0, 0, 0, total_issuance]
# Non-fungible faucet: The faucet data consists of SMT root containing minted non-fungible assets.
const.FAUCET_STORAGE_DATA_SLOT=0

# The maximum storage slot index
const.MAX_STORAGE_SLOT_INDEX=254

# The maximum number of account storage slots.
const.MAX_NUM_STORAGE_SLOTS=MAX_STORAGE_SLOT_INDEX+1

# Depth of the account database tree.
const.ACCOUNT_TREE_DEPTH=64

# The number of field elements it takes to store one account storage slot.
const.ACCOUNT_STORAGE_SLOT_DATA_LENGTH=8

# The number of field elements it takes to store one account procedure.
const.ACCOUNT_PROCEDURE_DATA_LENGTH=8

# EVENTS
# =================================================================================================

# Event emitted before an account storage item is updated.
const.ACCOUNT_STORAGE_BEFORE_SET_ITEM_EVENT=131076
# Event emitted after an account storage item is updated.
const.ACCOUNT_STORAGE_AFTER_SET_ITEM_EVENT=131077

# Event emitted before an account storage map item is updated.
const.ACCOUNT_STORAGE_BEFORE_SET_MAP_ITEM_EVENT=131078
# Event emitted after an account storage map item is updated.
const.ACCOUNT_STORAGE_AFTER_SET_MAP_ITEM_EVENT=131079

# Event emitted before an account nonce is incremented.
const.ACCOUNT_BEFORE_INCREMENT_NONCE_EVENT=131080
# Event emitted after an account nonce is incremented.
const.ACCOUNT_AFTER_INCREMENT_NONCE_EVENT=131081

# Event emitted to push the index of the account procedure at the top of the operand stack onto
# the advice stack.
const.ACCOUNT_PUSH_PROCEDURE_INDEX_EVENT=131082

# CONSTANT ACCESSORS
# =================================================================================================

#! Returns the account storage slot at which faucet data is stored.
#! Fungible faucet: The faucet data consists of [0, 0, 0, total_issuance]
#! Non-fungible faucet: The faucet data consists of SMT root containing minted non-fungible assets.
#!
#! Inputs:  []
#! Outputs: [faucet_storage_data_slot]
#!
#! Where:
#! - faucet_storage_data_slot is the account storage slot at which faucet data is stored.
export.get_faucet_storage_data_slot
    push.FAUCET_STORAGE_DATA_SLOT
end

#! Returns the maximum number of account storage slots.
#!
#! Inputs:  []
#! Outputs: [max_num_storage_slots]
#!
#! Where:
#! - max_num_storage_slots is the maximum number of account storage slots.
export.get_max_num_storage_slots
    push.MAX_NUM_STORAGE_SLOTS
end

#! Returns the maximum number of account interface procedures.
#!
#! Inputs:  []
#! Outputs: [max_num_procedures]
#!
#! Where:
#! - max_num_procedures is the maximum number of account interface procedures.
export.get_max_num_procedures
    push.MAX_NUM_PROCEDURES
end

# PROCEDURES
# =================================================================================================

#! Computes and returns the account hash from account data stored in memory.
#!
#! Inputs:  []
#! Outputs: [ACCT_HASH]
#!
#! Where:
#! - ACCT_HASH is the hash of the account data.
export.get_current_hash
    # prepare the stack for computing the account hash
    exec.memory::get_current_account_data_ptr padw padw padw

    # stream account data and compute sequential hash. We perform two `mem_stream` operations
    # because account data consists of exactly 4 words.
    mem_stream hperm mem_stream hperm

    # extract account hash
    exec.rpo::squeeze_digest

    # drop memory pointer
    movup.4 drop
end

#! Increments the account nonce by the provided value.
#!
#! Inputs:  [value]
#! Outputs: []
#!
#! Where:
#! - value is the value to increment the nonce by. value can be at most 2^32 - 1 otherwise this
#!   procedure panics.
export.incr_nonce
    u32assert.err=ERR_ACCOUNT_NONCE_INCREASE_MUST_BE_U32

    # emit event to signal that account nonce is being incremented
    push.20261 drop                                     # TODO: remove line, see miden-vm/#1122
    emit.ACCOUNT_BEFORE_INCREMENT_NONCE_EVENT

    exec.memory::get_acct_nonce add
    exec.memory::set_acct_nonce

    push.20357 drop                                     # TODO: remove line, see miden-vm/#1122
    emit.ACCOUNT_AFTER_INCREMENT_NONCE_EVENT
end

#! Returns the account id.
#!
#! Inputs:  []
#! Outputs: [acct_id]
#!
#! Where:
#! - acct_id is the account id.
export.memory::get_account_id->get_id

#! Returns the account nonce.
#!
#! Inputs:  []
#! Outputs: [nonce]
#!
#! Where:
#! - nonce is the account nonce.
export.memory::get_acct_nonce->get_nonce

#! Returns the initial account hash.
#!
#! Inputs:  []
#! Outputs: [INIT_HASH]
#!
#! Where:
#! - INIT_HASH is the initial account hash.
export.memory::get_init_acct_hash->get_initial_hash

#! Returns a boolean indicating whether the account is a fungible faucet.
#!
#! Inputs:  [acct_id_hi]
#! Outputs: [is_fungible_faucet]
#!
#! Where:
#! - acct_id_hi is the first felt of the account id.
#! - is_fungible_faucet is a boolean indicating whether the account is a fungible faucet.
export.is_fungible_faucet
    exec.type push.FUNGIBLE_FAUCET_ACCOUNT eq
    # => [is_fungible_faucet]
end

#! Returns a boolean indicating whether the account is a non-fungible faucet.
#!
#! Inputs:  [acct_id_hi]
#! Outputs: [is_non_fungible_faucet]
#!
#! Where:
#! - acct_id_hi is the first felt of the account id.
#! - is_non_fungible_faucet is a boolean indicating whether the account is a non-fungible faucet.
export.is_non_fungible_faucet
    exec.type push.NON_FUNGIBLE_FAUCET_ACCOUNT eq
    # => [is_non_fungible_faucet]
end

#! Returns a boolean indicating whether the account is a faucet.
#!
#! Inputs:  [acct_id_hi]
#! Outputs: [is_faucet]
#!
#! Where:
#! - acct_id_hi is the first felt of the account id.
#! - is_faucet is a boolean indicating whether the account is a faucet.
export.is_faucet
    u32split drop push.FAUCET_ACCOUNT u32and eq.0 not
    # => [is_faucet]
end

#! Returns a boolean indicating whether the account is a regular updatable account.
#!
#! Inputs:  [acct_id_hi]
#! Outputs: [is_updatable_account]
#!
#! Where:
#! - acct_id_hi is the first felt of the account id.
#! - is_updatable_account is a boolean indicating whether the account is a regular updatable
#!   account.
export.is_updatable_account
    exec.type push.REGULAR_ACCOUNT_UPDATABLE_CODE eq
    # => [is_updatable_account]
end

#! Returns a boolean indicating whether the account is a regular immutable account.
#!
#! Inputs:  [acct_id_hi]
#! Outputs: [is_immutable_account]
#!
#! Where:
#! - acct_id_hi is the first felt of the account id.
#! - is_immutable_account is a boolean indicating whether the account is a regular immutable
#!   account.
export.is_immutable_account
    exec.type push.REGULAR_ACCOUNT_IMMUTABLE_CODE eq
    # => [is_immutable_account]
end

#! Returns a boolean indicating whether the given account_ids are equal.
#!
#! Inputs:  [acct_id_hi, acct_id_lo, other_acct_id_hi, other_acct_id_lo]
#! Outputs: [is_id_equal]
#!
#! Where:
#! - acct_id_{hi,lo} are the first and second felt of an account id.
#! - other_acct_id_{hi,lo} are the first and second felt of the other account id to compare against.
#! - is_id_equal is a boolean indicating whether the account ids are equal.
export.is_id_eq
    movup.2 eq
    # => [is_hi_equal, acct_id_lo, other_acct_id_lo]
    movdn.2 eq
    # => [is_lo_equal, is_hi_equal]
    and
    # => [is_id_equal]
end

#! Validates an account id.
#!
#! Inputs:  [account_id_hi, account_id_lo]
#! Outputs: []
#!
#! Where:
#! - account_id_{hi,lo} are the first and second felt of the account id.
#!
#! Panics if:
#! - account_id_hi does not contain version zero.
#! - account_id_lo contains an anchor epoch that is greater or equal to 2^16.
#! - account_id_lo does not have its lower 8 bits set to zero.
export.validate_id
    # Validate version in first felt. For now only version 0 is supported.
    # ---------------------------------------------------------------------------------------------

    exec.id_version
    # => [id_version, account_id_lo]
    assertz.err=ERR_ACCOUNT_ID_UNKNOWN_VERSION
    # => [account_id_lo]

    # Validate anchor epoch is less than u16::MAX (0xffff) in second felt.
    # ---------------------------------------------------------------------------------------------

    dup exec.id_anchor_epoch
    # => [anchor_epoch, account_id_lo]
    lt.0xffff assert.err=ERR_ACCOUNT_ID_EPOCH_MUST_BE_LESS_THAN_U16_MAX
    # => [account_id_lo]

    # Validate lower 8 bits of second felt are zero.
    # ---------------------------------------------------------------------------------------------

    u32split drop u32and.0xff eq.0
    # => [is_least_significant_byte_zero]
    assert.err=ERR_ACCOUNT_ID_LEAST_SIGNIFICANT_BYTE_MUST_BE_ZERO
    # => []
end

#! Sets the code of the account the transaction is being executed against.
#!
#! Inputs:  [CODE_COMMITMENT]
#! Outputs: []
#!
#! Where:
#! - CODE_COMMITMENT is the hash of the code to set.
#!
#! Panics if:
#! - this procedure is executed on an account whose type differs from `regular mutable`.
export.set_code
    # get the account id
    exec.memory::get_account_id swap drop
    # => [acct_id_hi, CODE_COMMITMENT]

    # assert the account is an updatable regular account
    exec.is_updatable_account assert.err=ERR_ACCOUNT_CODE_IS_NOT_UPDATABLE
    # => [CODE_COMMITMENT]

    # set the code commitment
    exec.memory::set_new_acct_code_commitment dropw
    # => []
end

#! Applies storage offset to provided storage slot index for storage access.
#!
#! Inputs:  [storage_offset, storage_size, slot_index]
#! Outputs: [offset_slot_index]
#!
#! Where:
#! - storage_offset is the offset of the storage for this account component.
#! - storage_size is the number of storage slots accessible from this account component.
#! - slot_index is the index of the storage slot to be accessed.
#! - offset_slot_index is the final index of the storage slot with the storage offset applied to it.
#!
#! Panics if:
#! - the computed index is out of bounds
export.apply_storage_offset
    # offset index
    dup movup.3 add
    # => [offset_slot_index, storage_offset, storage_size]

    # verify that slot_index is in bounds
    movdn.2 add dup.1 gt assert.err=ERR_STORAGE_SLOT_INDEX_OUT_OF_BOUNDS
    # => [offset_slot_index]
end

#! Validates all account procedures storage metadata by checking that:
#! - All storage offsets and sizes are in bounds.
#! - All procedures not accessing storage have offset and size set to 0.
#! - No storage offset of a faucet account's procedure is 0 with a size != 0 (to prevent access to 
#!   the reserved storage slot).
#!
#! Inputs:  []
#! Outputs: []
export.validate_procedure_metadata
    # get number of account procedures and number of storage slots
    exec.memory::get_num_account_procedures exec.memory::get_num_storage_slots
    # => [num_storage_slots, num_account_procedures]

    # prepare stack for looping
    push.0.1
    # => [start_loop, index, num_storage_slots, num_account_procedures]

    # check if the account is a faucet
    exec.get_id swap drop exec.is_faucet
    # => [is_faucet, start_loop, index, num_storage_slots, num_account_procedures]

    # we do not check if num_account_procedures == 0 here because a valid
    # account has between 1 and 256 procedures with associated offsets
    if.true
        # This branch handles procedures from faucet accounts.
        while.true
            # get storage offset and size from memory
            dup exec.get_procedure_metadata
            # => [storage_offset, storage_size, index, num_storage_slots, num_account_procedures]

            # Procedures that do not access storage are defined with (offset, size) = (0, 0).
            # But we want to fail on tuples defined with a zero size but non-zero offset, since that
            # is a logic error.
            # We want to panic when we see this condition, so we use assertz rather than assert.
            # So we can assert this with: (size == 0 && offset != 0) == 0.
            dup.1 eq.0 dup.1 eq.0 not and assertz.err=ERR_ACCOUNT_INVALID_STORAGE_OFFSET_FOR_SIZE
            # => [storage_offset, storage_size, index, num_storage_slots, num_account_procedures]

            # No procedure should access the reserved faucet slot (slot 0). However (0, 0) should
            # still be allowed per the above.
            # We want to panic when we see this condition, so we use assertz rather than assert.
            # So we can assert this with: (offset == 0 && size != 0) == 0.
            dup.1 eq.0 not dup.1 eq.0 and assertz.err=ERR_FAUCET_INVALID_STORAGE_OFFSET
            # => [storage_offset, storage_size, index, num_storage_slots, num_account_procedures]

            # assert that storage offset is in bounds
            dup dup.4 lt assert.err=ERR_STORAGE_SLOT_INDEX_OUT_OF_BOUNDS
            # => [storage_offset, storage_size, index, num_storage_slots, num_account_procedures]

            # assert that storage limit is in bounds
            add dup.2 lte assert.err=ERR_STORAGE_SLOT_INDEX_OUT_OF_BOUNDS
            # => [index, num_storage_slots, num_account_procedures]

            # check if we should continue looping
            add.1 dup dup.3 lt
            # => [should_loop, index, num_storage_slots, num_account_procedures]
        end
    else
        # This branch handles procedures from regular accounts.
        while.true
            # get storage offset and size from memory
            dup exec.get_procedure_metadata
            # => [storage_offset, storage_size, index, num_storage_slots, num_account_procedures]

            # assert that storage offset is in bounds
            dup dup.4 lt assert.err=ERR_STORAGE_SLOT_INDEX_OUT_OF_BOUNDS
            # => [storage_offset, storage_size, index, num_storage_slots, num_account_procedures]

            # Procedures that do not access storage are defined with (offset, size) = (0, 0).
            # But we want to fail on tuples defined with a zero size but non-zero offset, since that
            # is a logic error.
            # We want to panic when we see this condition, so we use assertz rather than assert.
            # So we can assert this with: (size == 0 && offset != 0) == 0.
            dup.1 eq.0 dup.1 eq.0 not and assertz.err=ERR_ACCOUNT_INVALID_STORAGE_OFFSET_FOR_SIZE
            # => [storage_offset, storage_size, index, num_storage_slots, num_account_procedures]

            # assert that storage limit is in bounds
            add dup.2 lte assert.err=ERR_STORAGE_SLOT_INDEX_OUT_OF_BOUNDS
            # => [index, num_storage_slots, num_account_procedures]

            # check if we should continue looping
            add.1 dup dup.3 lt
            # => [should_loop, index, num_storage_slots, num_account_procedures]
        end
    end

    # clean stack
    drop drop drop
    # => []
end

#! Gets an item from the account storage.
#!
#! Note:
#! - We assume that index has been validated and is within bounds.
#!
#! Inputs:  [index]
#! Outputs: [VALUE]
#!
#! Where:
#! - index is the index of the item to get.
#! - VALUE is the value of the item.
export.get_item
    # get account storage slots section offset
    exec.memory::get_acct_storage_slots_section_ptr
    # => [acct_storage_slots_section_offset, index]

    # get the item from storage
    swap mul.2 add padw movup.4 mem_loadw
    # => [VALUE]
end

#! Sets an item in the account storage.
#!
#! Note:
#! - We assume that index has been validated and is within bounds.
#!
#! Inputs:  [index, V']
#! Outputs: [V]
#!
#! Where:
#! - index is the index of the item to set.
#! - V' is the value to set.
#! - V is the previous value of the item.
#!
#! Panics if:
#! - the storage slot type is not value.
export.set_item
    push.20443 drop                                     # TODO: remove line, see miden-vm/#1122
    emit.ACCOUNT_STORAGE_BEFORE_SET_ITEM_EVENT
    # => [index, V']

    # get storage slot type
    dup exec.get_storage_slot_type
    # => [storage_slot_type, index, V']

    # check if type == slot
    exec.constants::get_storage_slot_type_value eq
    assert.err=ERR_ACCOUNT_SETTING_VALUE_ITEM_ON_NON_VALUE_SLOT
    # => [index, V']

    # duplicate the index and the V' enabling emission of an
    # event after an account storage item is being updated
    movdn.4 dupw dup.8
    # => [index, V', V', index]

    # set V' in the storage slot
    exec.set_item_raw
    # => [V, V', index]

    # emit event to signal that an account storage item is being updated
    swapw movup.8
    push.20551 drop                                     # TODO: remove line, see miden-vm/#1122
    emit.ACCOUNT_STORAGE_AFTER_SET_ITEM_EVENT drop dropw
    # => [V]
end

#! Sets an item in the specified account storage map.
#!
#! Note:
#! - We assume that index has been validated and is within bounds.
#!
#! Inputs:  [index, KEY, NEW_VALUE, OLD_ROOT]
#! Outputs: [OLD_VALUE, NEW_ROOT]
#!
#! Where:
#! - OLD_ROOT is the root of the map to set the KEY NEW_VALUE pair.
#! - NEW_VALUE is the value to set under KEY.
#! - KEY is the key to set.
#! - OLD_VALUE is the previous value of the item.
#! - NEW_ROOT is the new root of the map.
#!
#! Panics if:
#! - the storage slot type is not map.
#! - no map is found for ROOT.
export.set_map_item.3
    # store index for later
    dup loc_store.0
    # => [index, KEY, NEW_VALUE, ...]

    # check if storage type is map
    dup exec.get_storage_slot_type
    # => [slot_type, index, KEY, NEW_VALUE, OLD_ROOT]

    # check if slot_type == map
    exec.constants::get_storage_slot_type_map eq 
    assert.err=ERR_ACCOUNT_SETTING_MAP_ITEM_ON_NON_MAP_SLOT
    # => [index, KEY, NEW_VALUE, OLD_ROOT]

    push.20693 drop                                     # TODO: remove line, see miden-vm/#1122
    emit.ACCOUNT_STORAGE_BEFORE_SET_MAP_ITEM_EVENT
    # => [index, KEY, NEW_VALUE, OLD_ROOT]

    # duplicate the KEY and the NEW_VALUE to be able to emit an event after an account storage item 
    # is being updated
    movdn.12 movupw.2 dupw.2 dupw.2
    # => [KEY, NEW_VALUE, OLD_ROOT, KEY, NEW_VALUE, index, ...]

    # set the NEW_VALUE under KEY in the tree
    # note smt::set expects the stack to be [NEW_VALUE, KEY, OLD_ROOT, ...]
    swapw exec.smt::set
    # => [OLD_VALUE, NEW_ROOT, KEY, NEW_VALUE, index, ...]

    # store OLD_VALUE and NEW_ROOT until the end of the procedure
    loc_storew.1 dropw loc_storew.2 dropw
    # => [KEY, NEW_VALUE, index, ...]

    # emit event to signal that an account storage item is being updated
    movup.8
    push.20771 drop                                     # TODO: remove line, see miden-vm/#1122
    emit.ACCOUNT_STORAGE_AFTER_SET_MAP_ITEM_EVENT drop
    # => [KEY, NEW_VALUE, ...]

    # load OLD_VALUE and NEW_ROOT on the top of the stack
    loc_loadw.2 swapw loc_loadw.1 swapw
    # => [NEW_ROOT, OLD_VALUE, ...]

    # set the root of the map in the respective account storage slot
    loc_load.0 exec.set_item_raw
    # => [OLD_MAP_ROOT, OLD_VALUE, ...]
end

#! Returns the type of the requested storage slot.
#!
#! Inputs:  [index]
#! Outputs: [slot_type]
#!
#! Where:
#! - index is the location in memory of the storage slot.
#! - slot_type is the type of the storage slot.
#!
#! Panics if:
#! - the slot index is out of bounds.
export.get_storage_slot_type
    # check that index is in bounds
    dup exec.memory::get_num_storage_slots lt assert.err=ERR_STORAGE_SLOT_INDEX_OUT_OF_BOUNDS
    # => [index, V']

    # get account storage slots section offset
    exec.memory::get_acct_storage_slots_section_ptr
    # => [acct_storage_slots_section_offset, index]

    # get storage slot type
    swap mul.2 add add.1 mem_load
    # => [slot_type]
end

#! Returns the procedure information.
#!
#! Inputs:  [index]
#! Outputs: [PROC_ROOT, storage_offset, storage_size]
#!
#! Where:
#! - PROC_ROOT is the hash of the procedure.
#! - storage_offset is the procedure storage offset.
#! - storage_size is the number of storage slots the procedure is allowed to access.
#!
#! Panics if:
#! - the procedure index is out of bounds.
export.get_procedure_info
    # check that index < number of procedures contained in the account code
    dup exec.memory::get_num_account_procedures lt assert.err=ERR_ACCOUNT_PROC_INDEX_OUT_OF_BOUNDS
    # => [index]

    # get procedure pointer
    mul.2 exec.memory::get_acct_procedures_section_ptr add dup add.1 swap
    # => [metadata_ptr, proc_ptr]

    # load procedure information from memory
    padw movup.4 mem_loadw padw movup.8 mem_loadw
    # => [METADATA, PROC_ROOT]

    # keep relevant data
    drop drop swap movdn.5 movdn.5
    # => [PROC_ROOT, storage_offset, storage_size]
end

#! Verifies that the procedure root is part of the account code.
#!
#! Inputs:  [PROC_ROOT]
#! Outputs: [storage_offset, storage_size]
#!
#! Where:
#! - PROC_ROOT is the hash of the procedure to authenticate.
#! - storage_offset is the procedure storage offset.
#! - storage_size is the number of storage slots the procedure is allowed to access.
#!
#! Panics if:
#! - the procedure root is not part of the account code.
export.authenticate_procedure
    # load procedure index
    push.20897 drop                                     # TODO: remove line, see miden-vm/#1122
    emit.ACCOUNT_PUSH_PROCEDURE_INDEX_EVENT adv_push.1
    # => [index, PROC_ROOT]

    # get procedure info (PROC_ROOT, storage_offset, storage_size) from memory stored at index
    exec.get_procedure_info
    # => [MEM_PROC_ROOT, storage_offset, storage_size, PROC_ROOT]

    # verify that PROC_ROOT exists in memory at index
    movup.4 movdn.9 movup.4 movdn.9 assert_eqw.err=ERR_ACCOUNT_PROC_NOT_PART_OF_ACCOUNT_CODE
    # => [storage_offset, storage_size]
end

#! Validates that the account seed, provided via the advice map, satisfies the seed requirements.
#!
#! Validation is performed via the following steps:
#! 1. Compute the hash of (SEED, CODE_COMMITMENT, STORAGE_COMMITMENT, ANCHOR_BLOCK_HASH).
#! 2. Assert the least significant element of the digest is equal to the account id of the account
#!    the transaction is being executed against.
#! 3. Assert the most significant element has sufficient proof of work (trailing zeros) for the 
#!    account type the transaction is being executed against.
#!
#! Inputs:  []
#! Outputs: []
export.validate_seed
    # Load the block hash of the anchor block from the chain mmr.
    # This is the block hash to which the account ID is anchored and is derived from.
    # ---------------------------------------------------------------------------------------------

    # prepare the advice map key for the seed for later
    exec.memory::get_account_id push.0.0
    # => [0, 0, account_id_hi, account_id_lo]

    # get the anchor block's number
    dup.3 exec.id_anchor_block_num
    # => [anchor_block_num, 0, 0, account_id_hi, account_id_lo]

    exec.memory::get_chain_mmr_ptr swap
    # => [anchor_block_num, chain_mmr_ptr, 0, 0, account_id_hi, account_id_lo]

    exec.mmr::get
    # => [ANCHOR_BLOCK_HASH, 0, 0, account_id_hi, account_id_lo]

    # assert that the anchor block hash is not the empty word
    padw eqw not assert.err=ERR_ACCOUNT_ANCHOR_BLOCK_HASH_MUST_NOT_BE_EMPTY dropw
    # => [ANCHOR_BLOCK_HASH, 0, 0, account_id_hi, account_id_lo]

    # Compute the hash of (SEED, CODE_COMMITMENT, STORAGE_COMMITMENT, ANCHOR_BLOCK_HASH).
    # ---------------------------------------------------------------------------------------------

    # prepare advice push_mapval
    swapw
    # => [0, 0, account_id_hi, account_id_lo, ANCHOR_BLOCK_HASH]

    # populate first four elements of the rate with the account id seed
    adv.push_mapval push.15263 drop         # TODO: remove line, see miden-vm/#1122
    adv_loadw
    # => [SEED, ANCHOR_BLOCK_HASH]

    # pad capacity element of hasher
    padw swapw
    # => [SEED, 0, 0, 0, 0, ANCHOR_BLOCK_HASH]

    # populate last four elements of the hasher rate with the code commitment
    exec.memory::get_acct_code_commitment
    # => [CODE_COMMITMENT, SEED, 0, 0, 0, 0, ANCHOR_BLOCK_HASH]

    # perform first permutation of seed and code_commitment (from advice stack) 
    # perm(seed, code_commitment)
    hperm
    # => [RATE, RATE, PERM, ANCHOR_BLOCK_HASH]

    # clear rate elements
    dropw dropw
    # => [PERM, ANCHOR_BLOCK_HASH]

    # perform second permutation perm(storage_commitment, 0, 0, 0, 0)
    swapw exec.memory::get_acct_storage_commitment swapw
    # => [ANCHOR_BLOCK_HASH, STORAGE_COMMITMENT, PERM]

    hperm
    # => [RATE, RATE, CAP]

    # extract digest
    exec.rpo::squeeze_digest
    # => [DIGEST]

    # Shape second felt to add the anchor epoch and compare computed and provided ID.
    # ---------------------------------------------------------------------------------------------

    # extract account id from digest
    drop drop swap
    # => [hashed_account_id_hi, hashed_account_id_lo]

    exec.memory::get_account_id movdn.3
    # => [account_id_lo, hashed_account_id_hi, hashed_account_id_lo, account_id_hi]

    # extract anchor epoch from ID of the new account
    dup movdn.4 exec.id_anchor_epoch
    # => [anchor_epoch, hashed_account_id_hi, hashed_account_id_lo, account_id_hi, account_id_lo]

    # shape second felt of hashed id, adding the anchor epoch and setting the lower 8 bits to zero
    movup.2 exec.shape_second_felt swap
    # => [hashed_account_id_hi, hashed_account_id_lo, account_id_hi, account_id_lo]

    # assert the account id matches the account id of the new account
    exec.is_id_eq assert.err=ERR_ACCOUNT_SEED_ANCHOR_BLOCK_HASH_DIGEST_MISMATCH
    # => []
end

#! Shapes the second felt so it meets the requirements of the account ID, by overwriting the
#! upper 16 bits with the anchor epoch and setting the lower 8 bits to zero.
#!
#! Inputs:  [seed_digest_lo, anchor_epoch]
#! Outputs: [account_id_lo]
#!
#! Where:
#! - seed_digest_lo is the second felt of the digest that should be shaped into the second felt
#!   of an account ID.
#! - account_id_lo is the second felt of an account ID.
#! - anchor_epoch is the epoch number to which this account ID is anchored.
proc.shape_second_felt
  u32split
  # => [seed_digest_lo_hi, seed_digest_lo_lo, anchor_epoch]

  # clear epoch bits in hi part so we can set them later
  u32and.0x0000ffff swap
  # => [seed_digest_lo_lo, seed_digest_lo_hi', anchor_epoch]

  # clear lower 8 bits of the lo part
  u32and.0xffffff00 swap.2
  # => [anchor_epoch, seed_digest_lo_hi', seed_digest_lo_lo']

  # assert epoch is not 2^16
  # this is technically optional as we will compare this id with the provided one for which
  # this property was already checked, but since this check is cheap we include it anyway
  dup eq.0xffff assertz.err=ERR_ACCOUNT_ID_EPOCH_MUST_BE_LESS_THAN_U16_MAX
  # => [anchor_epoch, seed_digest_lo_hi', seed_digest_lo_lo']

  # shift epoch left by 16 bits and set epoch bits on hi part
  u32shl.16 u32or
  # => [seed_digest_lo_hi'', seed_digest_lo_lo']

  # reassemble the second felt by multiplying the hi part with 2^32 and adding the lo part
  mul.0x0100000000 add
  # => [account_id_lo]
end

#! Extracts the block number of the anchor block from the second felt of an account ID.
#!
#! Inputs:  [account_id_lo]
#! Outputs: [anchor_block_num]
#!
#! Where:
#! - account_id_lo is the second felt of an account ID.
#! - anchor_block_num is the number of the block to which this account ID is anchored.
proc.id_anchor_block_num
  # extract the upper 32 bits
  u32split swap drop
  # => [account_id_lo_hi]

  # to get the epoch's block number we would have to multiply the epoch in the account id by 2^16
  # since the epoch is already in the upper 16 bits of the u32, we can simply zero out the
  # lower 16 bits to achieve the same result.
  u32and.0xffff0000
  # => [anchor_block_num]
end

#! Extracts the epoch from the second felt of an account ID.
#!
#! Inputs:  [account_id_lo]
#! Outputs: [anchor_epoch]
#!
#! Where:
#! - account_id_lo is the second felt of an account ID.
#! - anchor_epoch is the epoch number to which this account ID is anchored.
proc.id_anchor_epoch
  # extract the upper 32 bits
  u32split swap drop
  # => [account_id_lo_hi]

  # shift the upper 16 bits to the right to produce the epoch
  u32shr.16
  # => [anchor_epoch]
end

#! Extracts the account ID version from the first felt of an account ID.
#!
#! Inputs:  [account_id_hi]
#! Outputs: [id_version]
#!
#! Where:
#! - account_id_hi is the first felt of an account ID.
#! - id_version is the version number of the ID.
proc.id_version
  # extract the lower 32 bits
  u32split drop
  # => [account_id_hi_lo]

  # mask out the version
  u32and.ACCOUNT_VERSION_MASK_U32
  # => [id_version]
end

# DATA LOADERS
# =================================================================================================

#! Saves storage slots data into memory and validates that the storage commitment matches the 
#! sequential storage hash.
#!
#! Inputs:
#!   Operand stack: [STORAGE_COMMITMENT]
#!   Advice map: {
#!     STORAGE_COMMITMENT: [[STORAGE_SLOT_DATA]],
#!   }
#! Outputs:
#!   Operand stack: []
#! 
#! Where:
#! - STORAGE_COMMITMENT is the commitment of the current account's storage.
#! - STORAGE_SLOT_DATA is the data contained in the storage slot which is constructed as follows: 
#!   [SLOT_VALUE, slot_type, 0, 0, 0]
#!
#! Panics if:
#! - the number of account storage slots exceeded the maximum limit of 255.
#! - the computed account storage commitment does not match the provided account storage commitment
export.save_account_storage_data
    # move storage slot data from the advice map to the advice stack
    adv.push_mapvaln push.15160 drop                # TODO: remove line, see miden-vm/#1122
    # OS => [STORAGE_COMMITMENT]
    # AS => [storage_slot_data_len, [STORAGE_SLOT_DATA]]

    # push the length of the storage slot data onto the operand stack and compute the number of 
    # storage slots from it 
    adv_push.1 div.ACCOUNT_STORAGE_SLOT_DATA_LENGTH
    # OS => [num_storage_slots, STORAGE_COMMITMENT]
    # AS => [[STORAGE_SLOT_DATA]]

    # assert that account does not exceed allowed maximum number of storage slots
    dup exec.get_max_num_storage_slots lte assert.err=ERR_ACCOUNT_TOO_MANY_STORAGE_SLOTS
    # OS => [num_storage_slots, STORAGE_COMMITMENT]
    # AS => [[STORAGE_SLOT_DATA]]

    # store number of storage slots in memory
    dup exec.memory::set_num_storage_slots
    # OS => [num_storage_slots, STORAGE_COMMITMENT]
    # AS => [[STORAGE_SLOT_DATA]]

    # setup acct_storage_slots_ptr and end_ptr for reading from advice stack
    mul.2 exec.memory::get_acct_storage_slots_section_ptr dup movdn.2 add swap
    # OS => [acct_storage_slots_ptr, end_ptr, STORAGE_COMMITMENT]
    # AS => [[STORAGE_SLOT_DATA]]

    # pad stack before reading from advice stack
    padw padw padw
    # OS => [PAD, PAD, PAD, acct_proc_offset, end_ptr, STORAGE_COMMITMENT]
    # AS => [[STORAGE_SLOT_DATA]]

    # read the data from advice stack to memory and hash
    exec.mem::pipe_double_words_to_memory
    # OS => [PERM, PERM, PERM, end_ptr', STORAGE_COMMITMENT]
    # AS => []

    # extract the digest
    exec.rpo::squeeze_digest
    # OS => [DIGEST, end_ptr', STORAGE_COMMITMENT]

    # drop end_ptr
    movup.4 drop
    # OS => [DIGEST, STORAGE_COMMITMENT]

    # verify hashed account storage slots match account storage commitment
    assert_eqw.err=ERR_ACCOUNT_STORAGE_COMMITMENT_MISMATCH
    # OS => []
end

#! Saves account procedure data into memory and validates that the code commitment matches the 
#! sequential procedure hash.
#!
#! Inputs:
#!   Operand stack: [CODE_COMMITMENT]
#!   Advice map: {
#!     CODE_COMMITMENT: [[ACCOUNT_PROCEDURE_DATA]],
#!   }
#! Outputs:
#!   Operand stack: []
#! 
#! Where:
#! - CODE_COMMITMENT is the commitment of the current account's code.
#! - ACCOUNT_PROCEDURE_DATA is the information about account procedure which is constructed as 
#!   follows: [PROCEDURE_MAST_ROOT, storage_offset, storage_size, 0, 0]
#!
#! Panics if:
#! - the number of account procedures exceeded the maximum limit of 256
#! - the computed account code commitment does not match the provided account code commitment
export.save_account_procedure_data
    # move procedure data from the advice map to the advice stack
    adv.push_mapvaln push.15161 drop               # TODO: remove line, see miden-vm/#1122
    # OS => [CODE_COMMITMENT]
    # AS => [account_procedure_data_len, [ACCOUNT_PROCEDURE_DATA]]

    # push the length of the account procedure data onto the operand stack and compute the number of 
    # procedures from it 
    adv_push.1 div.ACCOUNT_PROCEDURE_DATA_LENGTH
    # OS => [num_procs, CODE_COMMITMENT]
    # AS => [[ACCOUNT_PROCEDURE_DATA]]

    # assert that account does not exceed allowed maximum number of procedures
    dup exec.get_max_num_procedures lte assert.err=ERR_ACCOUNT_TOO_MANY_PROCEDURES
    # OS => [num_procs, CODE_COMMITMENT]
    # AS => [[ACCOUNT_PROCEDURE_DATA]]

    # store number of procedures in memory
    dup exec.memory::set_num_account_procedures
    # OS => [num_procs, CODE_COMMITMENT]
    # AS => [[ACCOUNT_PROCEDURE_DATA]]

    # setup acct_proc_offset and end_ptr for reading from advice stack
    mul.2 exec.memory::get_acct_procedures_section_ptr dup movdn.2 add swap
    # OS => [acct_proc_offset, end_ptr, CODE_COMMITMENT]
    # AS => [[ACCOUNT_PROCEDURE_DATA]]

    # pad stack before reading from advice stack
    padw padw padw
    # OS => [PAD, PAD, PAD, acct_proc_offset, end_ptr, CODE_COMMITMENT]
    # AS => [[ACCOUNT_PROCEDURE_DATA]]

    # read the data from advice stack to memory and hash
    exec.mem::pipe_double_words_to_memory
    # OS => [PERM, PERM, PERM, end_ptr', CODE_COMMITMENT]
    # AS => []

    # extract the digest
    exec.rpo::squeeze_digest
    # OS => [DIGEST, end_ptr', CODE_COMMITMENT]

    # drop end_ptr
    movup.4 drop
    # OS => [DIGEST, CODE_COMMITMENT]

    # verify hashed account procedures match account code commitment
    assert_eqw.err=ERR_ACCOUNT_CODE_COMMITMENT_MISMATCH
    # OS => []
end

# HELPER PROCEDURES
# =================================================================================================

#! Returns the most significant half with the account type bits masked out.
#!
#! The account type can be defined by comparing this value with the following constants:
#! - REGULAR_ACCOUNT_UPDATABLE_CODE
#! - REGULAR_ACCOUNT_IMMUTABLE_CODE
#! - FUNGIBLE_FAUCET_ACCOUNT
#! - NON_FUNGIBLE_FAUCET_ACCOUNT
#!
#! Inputs:  [acct_id_hi]
#! Outputs: [acct_type]
#!
#! Where:
#! - acct_id_hi is the first felt of the account id.
#! - acct_type is the account type.
proc.type
    u32split drop push.ACCOUNT_ID_TYPE_MASK_U32 u32and
    # => [acct_type]
end

#! Sets an item in the account storage. Doesn't emit any events.
#!
#! Inputs:  [index, NEW_VALUE]
#! Outputs: [OLD_VALUE]
#!
#! Where:
#! - index is the index of the item to set.
#! - NEW_VALUE is the value to set.
#! - OLD_VALUE is the previous value of the item.
proc.set_item_raw
    # get old value from storage
    dup movdn.5 exec.get_item
    # => [OLD_VALUE, NEW_VALUE, index]

    # arrange stack for storage update
    swapw movup.8
    # => [index, NEW_VALUE, OLD_VALUE]

    # get account storage slots section offset
    exec.memory::get_acct_storage_slots_section_ptr
    # => [acct_storage_slots_section_offset, index, NEW_VALUE, OLD_VALUE]

    # update storage
    swap mul.2 add mem_storew
    # => [NEW_VALUE, OLD_VALUE]

    # drop value
    dropw
    # => [OLD_VALUE]
end

#! Returns the procedure metadata.
#!
#! Note:
#! - We assume that index has been validated and is within bounds.
#!
#! Inputs:  [index]
#! Outputs: [storage_offset, storage_size]
#!
#! Where:
#! - storage_offset is the procedure storage offset.
#! - storage_size is the number of storage slots the procedure is allowed to access.
proc.get_procedure_metadata
    # get procedure storage metadata pointer
    mul.2 exec.memory::get_acct_procedures_section_ptr add add.1
    # => [storage_offset_ptr]

    # load procedure metadata from memory and keep relevant data
    padw movup.4 mem_loadw drop drop swap
    # => [storage_offset, storage_size]
end

#! Returns the pointer to the next vacant memory slot if the account was not loaded before, and the 
#! pointer to the account data otherwise.
#!
#! Inputs:  [foreign_account_id_hi, foreign_account_id_lo]
#! Outputs: [was_loaded, ptr, foreign_account_id_hi, foreign_account_id_lo]
#!
#! Where: 
#! - foreign_account_id_{hi,lo} are the first and second felt of the ID of the foreign account
#!   whose procedure is going to be executed.
#! - was_loaded is the binary flag indicating whether the foreign account was already loaded to the
#!   memory.
#! - ptr is the memory pointer to the next empty memory slot or the memory pointer to the account
#!   data, depending on the value of the was_loaded flag.
#!
#! Panics if:
#! - the first or second felt of the provided foreign account ID equal zero.
#! - the maximum allowed number of foreign account to be loaded (64) was exceeded.
export.get_foreign_account_ptr
    # check that foreign account id is not equal zero
    dup.1 eq.0 dup.1 eq.0 and not assert.err=ERR_FOREIGN_ACCOUNT_ID_IS_ZERO
    # => [foreign_account_id_hi, foreign_account_id_lo]

    # check that foreign account id is not equal to the native account id
    dup.1 dup.1 exec.memory::get_native_account_id exec.is_id_eq not
    assert.err=ERR_FOREIGN_ACCOUNT_ID_EQUALS_NATIVE_ACCT_ID

    # get the initial account data pointer
    exec.memory::get_native_account_data_ptr
    # => [curr_account_ptr, foreign_account_id_hi, foreign_account_id_lo]

    # push the flag to enter the loop
    push.1

    while.true
        # drop the flag left from the previous loop
        # in the first iteration this will be a pad element
        movup.3 drop
        # => [curr_account_ptr, foreign_account_id_hi, foreign_account_id_lo]

        # move the current account pointer to the next account data block
        exec.memory::get_account_data_length add
        # => [curr_account_ptr', foreign_account_id_hi, foreign_account_id_lo]

        # load the first data word at the current account pointer
        padw dup.4 mem_loadw
        # => [FIRST_DATA_WORD, curr_account_ptr', foreign_account_id_hi, foreign_account_id_lo]

        # check whether the last value in the word equals zero
        # if so it means this memory block was not yet initialized
        drop drop dup.1 eq.0
        # => [is_empty_block, maybe_account_id_hi, maybe_account_id_lo, curr_account_ptr', foreign_account_id_hi, foreign_account_id_lo]

        # check whether the current id matches the foreign id
        movdn.2 dup.5 dup.5 exec.is_id_eq
        # => [is_equal_id, is_empty_word, curr_account_ptr', foreign_account_id_hi, foreign_account_id_lo]

        # get the loop flag
        # it equals 1 if both `is_equal_id` and `is_empty_block` flags are equal to 0, so we should 
        # continue iterating
        dup movdn.5 or not
        # => [loop_flag, curr_account_ptr', foreign_account_id_hi, foreign_account_id_lo, is_equal_id]
    end

    # check that the loading of one more account won't exceed the maximum number of the foreign 
    # accounts which can be loaded.
    dup exec.memory::get_max_foreign_account_ptr lte 
    assert.err=ERR_FOREIGN_ACCOUNT_MAX_NUMBER_EXCEEDED
    # => [curr_account_ptr, foreign_account_id_hi, foreign_account_id_lo, is_equal_id]

    # the resulting `was_loaded` flag is essentially equal to the `is_equal_id` flag
    movup.3
    # => [was_loaded, curr_account_ptr, foreign_account_id_hi, foreign_account_id_lo]
end

#! Checks that the state of the current foreign account is valid.
#!
#! Inputs:  []
#! Outputs: []
#!
#! Panics if:
#! - the hash of the current account is not represented in the account database.
export.validate_current_foreign_account
    # get the account database root
    exec.memory::get_acct_db_root
    # => [ACCOUNT_DB_ROOT]

    # TODO: Update when account tree was updated.
    # get the current account ID
    exec.memory::get_account_id swap drop
    # => [account_id_hi, ACCOUNT_DB_ROOT]

    # push the depth of the account database tree
    push.ACCOUNT_TREE_DEPTH
    # => [depth, account_id_hi, ACCOUNT_DB_ROOT]

    # get the foreign account hash
    exec.get_current_hash
    # => [FOREIGN_ACCOUNT_HASH, depth, account_id_hi, ACCOUNT_DB_ROOT]

    # verify that the account database has the hash of the current foreign account
    mtree_verify.err=ERR_FOREIGN_ACCOUNT_INVALID
    # => [FOREIGN_ACCOUNT_HASH, depth, account_id_hi, ACCOUNT_DB_ROOT]

    # clean the stack
    dropw drop drop dropw
end
