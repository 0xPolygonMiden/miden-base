# ERRORS
# =================================================================================================

# Unknown version in account id.
const.ERR_ACCOUNT_ID_UNKNOWN_VERSION=0x00020057

# Epoch must be less than u16::MAX (0xffff).
const.ERR_ACCOUNT_ID_EPOCH_MUST_BE_LESS_THAN_U16_MAX=0x00020058

# Least significant byte of second felt of the account id must be zero.
const.ERR_ACCOUNT_ID_LEAST_SIGNIFICANT_BYTE_MUST_BE_ZERO=0x00020005

# Provided storage slot index is out of bounds
const.ERR_STORAGE_SLOT_INDEX_OUT_OF_BOUNDS=0x0002000D

# CONSTANTS
# =================================================================================================

# The account storage slot at which faucet data is stored.
# Fungible faucet: The faucet data consists of [0, 0, 0, total_issuance]
# Non-fungible faucet: The faucet data consists of SMT root containing minted non-fungible assets.
const.FAUCET_STORAGE_DATA_SLOT=0

# The maximum storage slot index
const.MAX_STORAGE_SLOT_INDEX=254

# The maximum number of account storage slots.
const.MAX_NUM_STORAGE_SLOTS=MAX_STORAGE_SLOT_INDEX+1

# The maximum number of account interface procedures.
const.MAX_NUM_PROCEDURES=256

# Bit pattern for a faucet account, after the account type mask has been applied.
const.FAUCET_ACCOUNT=0x20 # 0b10_0000

# Bit pattern for an account w/ updatable code, after the account type mask has been applied.
const.REGULAR_ACCOUNT_UPDATABLE_CODE=0x10 # 0b01_0000

# Bit pattern for an account w/ immutable code, after the account type mask has been applied.
const.REGULAR_ACCOUNT_IMMUTABLE_CODE=0 # 0b00_0000

# Given the least significant 32 bits of an account id's first felt, this mask defines the bits used
# to determine the account type.
const.ACCOUNT_ID_TYPE_MASK_U32=0x30 # 0b11_0000

# Given the least significant 32 bits of an account id's first felt, this mask defines the bits used
# to determine the account version.
const.ACCOUNT_VERSION_MASK_U32=0x0f # 0b1111

# CONSTANT ACCESSORS
# =================================================================================================

#! Returns the account storage slot at which faucet data is stored.
#! Fungible faucet: The faucet data consists of [0, 0, 0, total_issuance]
#! Non-fungible faucet: The faucet data consists of SMT root containing minted non-fungible assets.
#!
#! Inputs:  []
#! Outputs: [faucet_storage_data_slot]
#!
#! Where:
#! - faucet_storage_data_slot is the account storage slot at which faucet data is stored.
export.get_faucet_storage_data_slot
    push.FAUCET_STORAGE_DATA_SLOT
end

#! Returns the maximum number of account storage slots.
#!
#! Inputs:  []
#! Outputs: [max_num_storage_slots]
#!
#! Where:
#! - max_num_storage_slots is the maximum number of account storage slots.
export.get_max_num_storage_slots
    push.MAX_NUM_STORAGE_SLOTS
end

#! Returns the maximum number of account interface procedures.
#!
#! Inputs:  []
#! Outputs: [max_num_procedures]
#!
#! Where:
#! - max_num_procedures is the maximum number of account interface procedures.
export.get_max_num_procedures
    push.MAX_NUM_PROCEDURES
end

# PROCEDURES
# =================================================================================================

#! Returns a boolean indicating whether the account is a fungible faucet.
#!
#! Inputs:  [acct_id_hi]
#! Outputs: [is_fungible_faucet]
#!
#! Where:
#! - acct_id_hi is the first felt of the account id.
#! - is_fungible_faucet is a boolean indicating whether the account is a fungible faucet.
export.::utils::is_fungible_faucet

#! Returns a boolean indicating whether the account is a non-fungible faucet.
#!
#! Inputs:  [acct_id_hi]
#! Outputs: [is_non_fungible_faucet]
#!
#! Where:
#! - acct_id_hi is the first felt of the account id.
#! - is_non_fungible_faucet is a boolean indicating whether the account is a non-fungible faucet.
export.::utils::is_non_fungible_faucet

#! Returns a boolean indicating whether the given account_ids are equal.
#!
#! Inputs:  [acct_id_hi, acct_id_lo, other_acct_id_hi, other_acct_id_lo]
#! Outputs: [is_id_equal]
#!
#! Where:
#! - acct_id_{hi,lo} are the first and second felt of an account id.
#! - other_acct_id_{hi,lo} are the first and second felt of the other account id to compare against.
#! - is_id_equal is a boolean indicating whether the account ids are equal.
export.::utils::is_id_eq

#! Returns a boolean indicating whether the account is a faucet.
#!
#! Inputs:  [acct_id_hi]
#! Outputs: [is_faucet]
#!
#! Where:
#! - acct_id_hi is the first felt of the account id.
#! - is_faucet is a boolean indicating whether the account is a faucet.
export.is_faucet
    u32split drop push.FAUCET_ACCOUNT u32and eq.0 not
    # => [is_faucet]
end

#! Returns a boolean indicating whether the account is a regular updatable account.
#!
#! Inputs:  [acct_id_hi]
#! Outputs: [is_updatable_account]
#!
#! Where:
#! - acct_id_hi is the first felt of the account id.
#! - is_updatable_account is a boolean indicating whether the account is a regular updatable
#!   account.
export.is_updatable_account
    exec.type push.REGULAR_ACCOUNT_UPDATABLE_CODE eq
    # => [is_updatable_account]
end

#! Returns a boolean indicating whether the account is a regular immutable account.
#!
#! Inputs:  [acct_id_hi]
#! Outputs: [is_immutable_account]
#!
#! Where:
#! - acct_id_hi is the first felt of the account id.
#! - is_immutable_account is a boolean indicating whether the account is a regular immutable
#!   account.
export.is_immutable_account
    exec.type push.REGULAR_ACCOUNT_IMMUTABLE_CODE eq
    # => [is_immutable_account]
end

#! Validates an account id.
#!
#! Inputs:  [account_id_hi, account_id_lo]
#! Outputs: []
#!
#! Where:
#! - account_id_{hi,lo} are the first and second felt of the account id.
#!
#! Panics if:
#! - account_id_hi does not contain version zero.
#! - account_id_lo contains an anchor epoch that is greater or equal to 2^16.
#! - account_id_lo does not have its lower 8 bits set to zero.
export.validate_id
    # Validate version in first felt. For now only version 0 is supported.
    # ---------------------------------------------------------------------------------------------

    exec.id_version
    # => [id_version, account_id_lo]
    assertz.err=ERR_ACCOUNT_ID_UNKNOWN_VERSION
    # => [account_id_lo]

    # Validate anchor epoch is less than u16::MAX (0xffff) in second felt.
    # ---------------------------------------------------------------------------------------------

    dup exec.id_anchor_epoch
    # => [anchor_epoch, account_id_lo]
    lt.0xffff assert.err=ERR_ACCOUNT_ID_EPOCH_MUST_BE_LESS_THAN_U16_MAX
    # => [account_id_lo]

    # Validate lower 8 bits of second felt are zero.
    # ---------------------------------------------------------------------------------------------

    u32split drop u32and.0xff eq.0
    # => [is_least_significant_byte_zero]
    assert.err=ERR_ACCOUNT_ID_LEAST_SIGNIFICANT_BYTE_MUST_BE_ZERO
    # => []
end

#! Applies storage offset to provided storage slot index for storage access.
#!
#! Inputs:  [storage_offset, storage_size, slot_index]
#! Outputs: [offset_slot_index]
#!
#! Where:
#! - storage_offset is the offset of the storage for this account component.
#! - storage_size is the number of storage slots accessible from this account component.
#! - slot_index is the index of the storage slot to be accessed.
#! - offset_slot_index is the final index of the storage slot with the storage offset applied to it.
#!
#! Panics if:
#! - the computed index is out of bounds
export.apply_storage_offset
    # offset index
    dup movup.3 add
    # => [offset_slot_index, storage_offset, storage_size]

    # verify that slot_index is in bounds
    movdn.2 add dup.1 gt assert.err=ERR_STORAGE_SLOT_INDEX_OUT_OF_BOUNDS
    # => [offset_slot_index]
end

#! Shapes the second felt so it meets the requirements of the account ID, by overwriting the
#! upper 16 bits with the anchor epoch and setting the lower 8 bits to zero.
#!
#! Inputs:  [seed_digest_lo, anchor_epoch]
#! Outputs: [account_id_lo]
#!
#! Where:
#! - seed_digest_lo is the second felt of the digest that should be shaped into the second felt
#!   of an account ID.
#! - account_id_lo is the second felt of an account ID.
#! - anchor_epoch is the epoch number to which this account ID is anchored.
proc.shape_second_felt
  u32split
  # => [seed_digest_lo_hi, seed_digest_lo_lo, anchor_epoch]

  # clear epoch bits in hi part so we can set them later
  u32and.0x0000ffff swap
  # => [seed_digest_lo_lo, seed_digest_lo_hi', anchor_epoch]

  # clear lower 8 bits of the lo part
  u32and.0xffffff00 swap.2
  # => [anchor_epoch, seed_digest_lo_hi', seed_digest_lo_lo']

  # assert epoch is not 2^16
  # this is technically optional as we will compare this id with the provided one for which
  # this property was already checked, but since this check is cheap we include it anyway
  dup eq.0xffff assertz.err=ERR_ACCOUNT_ID_EPOCH_MUST_BE_LESS_THAN_U16_MAX
  # => [anchor_epoch, seed_digest_lo_hi', seed_digest_lo_lo']

  # shift epoch left by 16 bits and set epoch bits on hi part
  u32shl.16 u32or
  # => [seed_digest_lo_hi'', seed_digest_lo_lo']

  # reassemble the second felt by multiplying the hi part with 2^32 and adding the lo part
  mul.0x0100000000 add
  # => [account_id_lo]
end

#! Extracts the block number of the anchor block from the second felt of an account ID.
#!
#! Inputs:  [account_id_lo]
#! Outputs: [anchor_block_num]
#!
#! Where:
#! - account_id_lo is the second felt of an account ID.
#! - anchor_block_num is the number of the block to which this account ID is anchored.
proc.id_anchor_block_num
  # extract the upper 32 bits
  u32split swap drop
  # => [account_id_lo_hi]

  # to get the epoch's block number we would have to multiply the epoch in the account id by 2^16
  # since the epoch is already in the upper 16 bits of the u32, we can simply zero out the
  # lower 16 bits to achieve the same result.
  u32and.0xffff0000
  # => [anchor_block_num]
end

#! Extracts the epoch from the second felt of an account ID.
#!
#! Inputs:  [account_id_lo]
#! Outputs: [anchor_epoch]
#!
#! Where:
#! - account_id_lo is the second felt of an account ID.
#! - anchor_epoch is the epoch number to which this account ID is anchored.
proc.id_anchor_epoch
  # extract the upper 32 bits
  u32split swap drop
  # => [account_id_lo_hi]

  # shift the upper 16 bits to the right to produce the epoch
  u32shr.16
  # => [anchor_epoch]
end

#! Extracts the account ID version from the first felt of an account ID.
#!
#! Inputs:  [account_id_hi]
#! Outputs: [id_version]
#!
#! Where:
#! - account_id_hi is the first felt of an account ID.
#! - id_version is the version number of the ID.
proc.id_version
  # extract the lower 32 bits
  u32split drop
  # => [account_id_hi_lo]

  # mask out the version
  u32and.ACCOUNT_VERSION_MASK_U32
  # => [id_version]
end

# HELPER PROCEDURES
# =================================================================================================

#! Returns the most significant half with the account type bits masked out.
#!
#! The account type can be defined by comparing this value with the following constants:
#! - REGULAR_ACCOUNT_UPDATABLE_CODE
#! - REGULAR_ACCOUNT_IMMUTABLE_CODE
#! - FUNGIBLE_FAUCET_ACCOUNT
#! - NON_FUNGIBLE_FAUCET_ACCOUNT
#!
#! Inputs:  [acct_id_hi]
#! Outputs: [acct_type]
#!
#! Where:
#! - acct_id_hi is the first felt of the account id.
#! - acct_type is the account type.
proc.type
    u32split drop push.ACCOUNT_ID_TYPE_MASK_U32 u32and
    # => [acct_type]
end