use.std::collections::smt
use.std::collections::mmr
use.std::crypto::hashes::native

use.miden::kernels::tx::account
use.miden::kernels::tx::asset_vault
use.miden::kernels::tx::constants
use.miden::kernels::tx::memory
use.miden::kernels::tx::utils

#Â ERRORS
# =================================================================================================

# The global inputs provided do not match the block hash commitment
const.ERR_PROLOGUE_GLOBAL_INPUTS_MISMATCH=0x0002000B

# The account storage data does not match its commitment
const.ERR_PROLOGUE_ACCT_STORAGE_MISMATCH=0x0002000C

# Data store in account's storage exceeds the maximum capacity of 256 elements
const.ERR_PROLOGUE_ACCT_STORAGE_ARITY_TOO_HIGH=0x0002000D

# Data store in account's storage contains invalid type discriminant
const.ERR_PROLOGUE_ACCT_STORAGE_TYPE_INVALID=0x0002000E

# New account must have an empty vault
const.ERR_PROLOGUE_NEW_ACCT_VAULT_NOT_EMPTY=0x0002000F

# New account must have valid slot types
const.ERR_PROLOGUE_NEW_ACCT_INVALID_SLOT_TYPE=0x00020010

# Reserved slot for new fungible faucet is not empty
const.ERR_PROLOGUE_NEW_FUNGIBLE_FAUCET_NON_EMPTY_RESERVED_SLOT=0x00020011

# Reserved slot for new fungible faucet has a non-zero arity
const.ERR_PROLOGUE_NEW_FUNGIBLE_FAUCET_NON_ZERO_RESERVED_SLOT=0x00020012

# Reserved slot for new fungible faucet has an invalid type
const.ERR_PROLOGUE_NEW_FUNGIBLE_FAUCET_INVALID_TYPE_RESERVED_SLOT=0x00020013

# Reserved slot for non-fungible faucet is not a valid empty SMT
const.ERR_PROLOGUE_NEW_NON_FUNGIBLE_FAUCET_INVALID_RESERVED_SLOT=0x00020014

# Reserved slot for new non-fungible faucet has a non-zero arity
const.ERR_PROLOGUE_NEW_NON_FUNGIBLE_FAUCET_NON_ZERO_RESERVED_SLOT=0x00020015

# Reserved slot for new non-fungible faucet has an invalid type
const.ERR_PROLOGUE_NEW_NON_FUNGIBLE_FAUCET_INVALID_TYPE_RESERVED_SLOT=0x00020016

# Account data provided does not match the commitment recorded on-chain
const.ERR_PROLOGUE_ACCT_HASH_MISMATCH=0x00020017

# Existing account must have a non-zero nonce
const.ERR_PROLOGUE_OLD_ACCT_NONCE_ZERO=0x00020018

# Provided account ids via global inputs and advice provider do not match
const.ERR_PROLOGUE_ACCT_ID_MISMATCH=0x00020019

# Reference block MMR and note's authentication MMR must match
const.ERR_PROLOGUE_NOTE_MMR_DIGEST_MISMATCH=0x0002001A

# Number of note inputs exceeded the maximum limit of 128
const.ERR_PROLOGUE_NOTE_TOO_MANY_INPUTS=0x0002001B

# Number of note assets exceeded the maximum limit of 256
const.ERR_PROLOGUE_NOTE_TOO_MANY_ASSETS=0x0002001C

# Provided info about assets of an input do not match its commitment
const.ERR_PROLOGUE_NOTE_CONSUMED_ASSETS_MISMATCH=0x0002001D

# Number of input notes exceeded the kernel's maximum limit of 1023
const.ERR_PROLOGUE_TOO_MANY_INPUT_NOTES=0x0002001E

# Cannot compute matching nullifier commitment using the provided input note data
const.ERR_PROLOGUE_INPUT_NOTES_NULLIFIER_COMMITMENT_MISMATCH=0x0002001F

# PUBLIC INPUTS
# =================================================================================================

#! Saves global inputs to memory.
#!
#! Stack: [BLOCK_HASH, acct_id, INITIAL_ACCOUNT_HASH, NULLIFIER_COMMITMENT]
#! Output: []
#!
#! - BLOCK_HASH, reference block for the transaction execution.
#! - acct_id is the account id of the account that the transaction is being executed against.
#! - INITIAL_ACCOUNT_HASH, account state prior to the transaction, ZERO for new accounts.
#! - NULLIFIER_COMMITMENT, sequential hash of all input notes' nullifiers.
proc.process_global_inputs
    exec.memory::set_block_hash
    exec.memory::set_global_acct_id
    exec.memory::set_init_acct_hash
    exec.memory::set_nullifier_commitment
end

# BLOCK DATA
# =================================================================================================

#! Saves block data to memory and verifies that it matches the BLOCK_HASH public input.
#!
#! Stack: []
#! Advice stack: [
#!     PREVIOUS_BLOCK_HASH,
#!     CHAIN_MMR_HASH,
#!     ACCOUNT_ROOT,
#!     NULLIFIER_ROOT,
#!     BATCH_ROOT,
#!     PROOF_HASH,
#!     [block_num, version, timestamp, 0],
#!     ZERO,
#!     NOTE_ROOT,
#! ]
#! Output: []
#!
#! Where:
#! - PREVIOUS_BLOCK_HASH, hash of the previous block.
#! - CHAIN_MMR_HASH, sequential hash of the reference MMR.
#! - ACCOUNT_ROOT, rollup tree with latest account states.
#! - NULLIFIER_ROOT, epoch tree with the nullifiers of consumed notes.
#! - BATCH_ROOT, tree of batches included in the block.
#! - PROOF_HASH, hash of the block's stark proof.
#! - block_num, the reference block number.
#! - version, current protocol version.
#! - timestamp, current timestamp.
#! - NOTE_ROOT, epoch tree with created notes.
proc.process_block_data
    exec.memory::get_block_data_ptr
    # => [block_data_ptr]

    # read block data and compute its digest
    padw padw padw
    adv_pipe hperm
    adv_pipe hperm
    adv_pipe hperm
    adv_pipe hperm
    exec.native::state_to_digest
    # => [DIG, block_data_ptr']

    # store the note root in memory
    padw adv_loadw
    dupw exec.memory::set_note_root
    # => [NOTE_ROOT, DIG, block_data_ptr']

    # merge the note root with the block data digest
    hmerge
    # => [BLOCK_HASH, block_data_ptr']

    # assert that the block hash matches the hash in global inputs
    exec.memory::get_block_hash
    assert_eqw.err=ERR_PROLOGUE_GLOBAL_INPUTS_MISMATCH
    # => [block_data_ptr']

    drop
    # => []
end

# CHAIN DATA
# =================================================================================================

#! Saves the MMR peaks to memory and verifies that it matches the reference block's CHAIN_MMR_HASH.
#!
#! This procedure loads the MMR peaks from the advice provider, verifies their hash matches the
#! reference block, and insert the reference block in the MMR. The reference block is added to the
#! MMR so that notes created at this block can be consumed, since the MMR can't contain it and is
#! always one block behind. The number MMR peaks in is variable, from 16 up to 63, depending on
#! `num_blocks`.
#!
#! Stack: []
#! Advice Map: {CHAIN_MMR_HASH: [[num_blocks, 0, 0, 0], PEAK_1, ..., PEAK_N]}
#! Output: []
#!
#! Where:
#! - CHAIN_MMR_HASH, is the sequential hash of the padded MMR peaks.
#! - num_blocks, is the number of blocks in the MMR.
#! - PEAK_1 .. PEAK_N, are the MMR peaks.
proc.process_chain_data
    exec.memory::get_chain_mmr_ptr dup
    # => [chain_mmr_ptr, chain_mmr_ptr]

    # save the MMR peaks to memory and verify it mathes the block's CHAIN_ROOT
    exec.memory::get_chain_root
    exec.mmr::unpack
    # => [chain_mmr_ptr]

    # add the current block's hash to the MMR, enabling authentication of notes created in it
    exec.memory::get_block_hash
    exec.mmr::add
    # => []
end

# ACCOUNT DATA
# =================================================================================================

#! Ingests the account storage slot type data and stores it in memory at the appropriate memory
#! addresses.
#!
#! This is achieved by reading the storage type commitment from storage slot 255 and then reading
#! the storage type data from the advice provider.
#!
#! Stack: []
#! Merkle Store: { ACCT_STORAGE[slot_255] -> TYPES_COM }
#! Advice Map: { TYPES_COM: [slot_0_type, slot_1_type, ..., slot_255_type] }
#! Output: []
proc.ingest_acct_storage_types
    # get the storage slot types commitment
    exec.account::get_slot_types_commitment_storage_slot exec.account::get_item
    # => [TYPES_COM]

    # load the type data from the advice map onto the advice stack
    # we prefix with [push.1 drop] due to https://github.com/0xPolygonMiden/miden-vm/issues/1122
    push.1 drop adv.push_mapval
    # => [TYPES_COM]

    # get the storage slot types data pointer
    exec.memory::get_acct_storage_slot_type_data_ptr
    # => [slot_type_data_ptr, TYPES_COM]

    # prepare the stack for reading storage slot types
    padw padw padw
    # => [ZERO, ZERO, ZERO, slot_type_data_ptr, TYPES_COM]

    # read the storage slot types from the advice provider and store in memory
    repeat.32
        adv_pipe hperm
        # => [PERM, PERM, PERM, slot_type_data_ptr', TYPES_COM]
    end

    # extract the digest and drop the memory pointer
    exec.native::state_to_digest movup.4 drop
    # => [DIGEST, TYPES_COM]

    # assert the digest matches the commitment
    assert_eqw.err=ERR_PROLOGUE_ACCT_STORAGE_MISMATCH
    # => []
end

#! Validates that storage slot types are well formed.
#!
#! This is achieved by reading the storage slot types from memory and asserting that they are
#! well formed. Currently we only support scalar slots with an entry of maximum arity of 256.
#!
#! Stack: []
#! Output: []
proc.validate_storage_slot_types
    # get the pointer at which the storage slot type data begins
    exec.memory::get_acct_storage_slot_type_data_ptr
    # => [slot_type_data_ptr]

    repeat.32
        # read the storage slot types from memory
        padw dup.4 mem_loadw
        # => [slot_i_type, slot_i+1_type, slot_i+2_type, slot_i+3_type, slot_type_data_ptr]

        repeat.4
            # split the type to get the slot type and entry arity
            u32split
            # => [arity, type, ...]

            # assert the entry arity is less than or equal to 255
            u32split assertz.err=ERR_PROLOGUE_ACCT_STORAGE_ARITY_TOO_HIGH
            push.255 u32lte assert.err=ERR_PROLOGUE_ACCT_STORAGE_ARITY_TOO_HIGH
            # => [type, ...]

            # assert the slot type is valid
            u32split assertz.err=ERR_PROLOGUE_ACCT_STORAGE_TYPE_INVALID
            exec.account::get_max_slot_type u32lte assert.err=ERR_PROLOGUE_ACCT_STORAGE_TYPE_INVALID
            # => [...]
        end
        # => [slot_type_data_ptr]

        # increment the slot type data pointer
        add.1
        # => [slot_type_data_ptr']
    end

    # drop the slot type data pointer
    drop
    # => []
end

#! Validates that the account the transaction is being executed against satisfies the criteria
#! for a new account.
#!
#! Stack: []
#! Output: []
#!
#!
#! Apply the following validation to the new account:
#!   * assert that the account id is valid.
#!   * assert that the account vault is empty.
#!   * assert that the account nonce is set to 0.
#!   * read the account seed from the advice provider and assert it satisfies seed requirements.
proc.validate_new_account
    # Assert the account id of the account is valid
    exec.memory::get_acct_id exec.account::validate_id
    # => []

    # Assert the account nonce is 0
    exec.memory::get_acct_nonce eq.0 assert
    # => []

    # Assert the initial vault is empty
    # -----------------------------------------------------------------------------------------
    # get the account vault root
    exec.memory::get_acct_vault_root
    # => [ACCT_VAULT_ROOT]

    # push empty vault root onto stack
    exec.constants::get_empty_smt_root
    # => [EMPTY_VAULT_ROOT, ACCT_VAULT_ROOT]

    assert_eqw.err=ERR_PROLOGUE_NEW_ACCT_VAULT_NOT_EMPTY
    # => []

    # Assert storage slot types are well formed
    # -----------------------------------------------------------------------------------------
    # validate storage slot types
    exec.validate_storage_slot_types
    # => []

    # Assert slot types reserved slot is correctly initialized
    # -----------------------------------------------------------------------------------------
    exec.account::get_slot_types_commitment_storage_slot exec.account::get_storage_slot_type_info
    # => [entry_arity, storage_type]

    # assert the slot type is a scalar of arity 64
    push.64
    assert_eq.err=ERR_PROLOGUE_NEW_ACCT_INVALID_SLOT_TYPE
    assertz.err=ERR_PROLOGUE_NEW_ACCT_INVALID_SLOT_TYPE
    # => []

    drop drop

    # Assert faucet reserved slot is correctly initialized
    # -----------------------------------------------------------------------------------------
    # check if the account is a faucet
    exec.account::get_id dup exec.account::is_faucet
    # => [is_faucet, acct_id]

    # process conditional logic depending on whether the account is a faucet
    if.true
        # get the faucet reserved slot
        exec.account::get_faucet_storage_data_slot exec.account::get_item
        # => [FAUCET_RESERVED_SLOT, acct_id]

        # check if the account is a fungible faucet
        movup.4 exec.account::is_fungible_faucet
        # => [is_fungible_faucet, FAUCET_RESERVED_SLOT]

        if.true
            # assert the fungible faucet reserved slot is initialized correctly (EMPTY_WORD)
            or or or assertz.err=ERR_PROLOGUE_NEW_FUNGIBLE_FAUCET_NON_EMPTY_RESERVED_SLOT
            # => []

            # get the faucet reserved storage data slot type and entry arity
            exec.account::get_faucet_storage_data_slot exec.account::get_storage_slot_type_info
            # => [entry_arity, storage_type]

            # assert the fungible faucet reserved slot type is a scalar of arity 0
            assertz.err=ERR_PROLOGUE_NEW_FUNGIBLE_FAUCET_NON_ZERO_RESERVED_SLOT
            assertz.err=ERR_PROLOGUE_NEW_FUNGIBLE_FAUCET_INVALID_TYPE_RESERVED_SLOT
            # => []
        else
            # assert the non-fungible faucet reserved slot is initialized correctly (root of
            # empty SMT)
            exec.constants::get_empty_smt_root assert_eqw.err=ERR_PROLOGUE_NEW_NON_FUNGIBLE_FAUCET_INVALID_RESERVED_SLOT
            # => []

            # get the faucet reserved storage data slot type and entry arity
            exec.account::get_faucet_storage_data_slot exec.account::get_storage_slot_type_info
            # => [entry_arity, storage_type]

            # assert the non-fungible faucet reserved slot type is a map of arity 0
            assertz.err=ERR_PROLOGUE_NEW_NON_FUNGIBLE_FAUCET_NON_ZERO_RESERVED_SLOT
            assert.err=ERR_PROLOGUE_NEW_NON_FUNGIBLE_FAUCET_INVALID_TYPE_RESERVED_SLOT
            # => []
        end
    else
        # drop the account id
        drop
        # => []
    end

    # Assert the provided account seed satisfies the seed requirements
    # -----------------------------------------------------------------------------------------
    exec.account::validate_seed
    # => []
end

#! Saves the account data to memory and validates it.
#!
#! This procedure will:
#!
#! - Read the account data from the advice stack
#! - Save it to memory
#! - For new accounts, signaled by having a INITIAL_ACCOUNT_HASH set to ZERO as a global input,
#!   validate the account's id and initial state
#! - For existing accounts, verify the INITIAL_ACCOUNT_HASH commitment matches the provided data,
#!   and the account nonce is not zero
#!
#! Stack: []
#! Advice stack: [[account_id, 0, 0, account_nonce], ACCOUNT_VAULT_ROOT, ACCOUNT_STORAGE_ROOT, ACCOUNT_CODE_ROOT]
#! Output: []
#!
#! Where:
#! - account_id, the account that the transaction is being executed against.
#! - account_nonce, account's nonce.
#! - ACCOUNT_VAULT_ROOT, account's vault root.
#! - ACCOUNT_STORAGE_ROOT, account's storage root.
#! - ACCOUNT_CODE_ROOT, account's code root.
proc.process_account_data
    # Copy the account data from the advice stack to memory and hash it
    # ---------------------------------------------------------------------------------------------

    exec.memory::get_acct_data_ptr
    # => [acct_data_ptr]

    # read account data and compute its digest
    padw padw padw
    adv_pipe hperm
    adv_pipe hperm
    exec.native::state_to_digest
    # => [ACCT_HASH, acct_data_ptr']

    movup.4 drop
    # => [ACCT_HASH]

    # Validate the account
    # ---------------------------------------------------------------------------------------------

    # It is a new account if the global input INITIAL_ACCOUNT_HASH was set to ZERO.
    padw exec.memory::get_init_acct_hash eqw
    # => [is_new, INITIAL_ACCOUNT_HASH, ZERO, ACCT_HASH]

    # clean the stack
    movdn.8 dropw dropw
    # => [is_new, ACCT_HASH]

    # ingest storage slot type data
    exec.ingest_acct_storage_types
    # => [is_new, ACCT_HASH]

    # process conditional logic depending on whether the account is new or existing
    if.true
        # set the initial account hash
        exec.memory::set_init_acct_hash
        # => []

        # validate the new account
        exec.validate_new_account
        # => []
    else
        # assert that the existing account hash matches the hash in global inputs
        exec.memory::get_init_acct_hash
        assert_eqw.err=ERR_PROLOGUE_ACCT_HASH_MISMATCH
        # => []

        # assert the nonce of an existing account is non-zero
        exec.memory::get_acct_nonce neq.0
        assert.err=ERR_PROLOGUE_OLD_ACCT_NONCE_ZERO
        # => []
    end

    # Set the account storage, vault, code, and nonce memory locations
    # ---------------------------------------------------------------------------------------------

    # assert the account id matches the account id in global inputs
    exec.memory::get_global_acct_id
    exec.memory::get_acct_id
    assert_eq.err=ERR_PROLOGUE_ACCT_ID_MISMATCH
    # => []

    # store a copy of the initial nonce in global inputs
    exec.memory::get_acct_nonce
    exec.memory::set_init_nonce
    # => []

    # set the new account code root to the initial account code root this is used for managing
    # code root updates
    exec.memory::get_acct_code_root
    exec.memory::set_new_acct_code_root
    # => []

    # copy the initial account vault hash to the input vault hash to support transaction asset
    # invariant checking
    exec.memory::get_acct_vault_root exec.memory::set_input_vault_root
    # => []
end

# INPUT NOTES DATA
# =================================================================================================

#! Authenticate the input note data provided via the advice provider is consistent with the
#! the chain history.  This is achieved by:
#! - authenticating the MMR leaf associated with the block the note was created in.
#! - authenticating the note root associated with the block the note was created in.
#! - authenticating the note and its metadata in the note Merkle tree from the block the note was
#!   created in.
#!
#! Operand stack: [AUTH_DIGEST]
#! Advice stack: [leaf_pos, SUB_HASH, NOTE_ROOT, note_index]
#! Output: []
#!
#! Where:
#! - AUTH_DIGEST is the digest of the input note data computed as hash(NOTE_HASH, NOTE_METADATA).
#! - leaf_pos is the position of the leaf in the MMR associated with the block the note was created.
#!   in. This is equivalent to the block number.
#! - SUB_HASH is the sub hash of the block the note was created in.
#! - NOTE_ROOT is the note root of the block the note was created in.
#! - note_index is the index of the note in the note Merkle tree.
proc.authenticate_note.2
    # load data required for MMR get operation
    exec.memory::get_chain_mmr_ptr adv_push.1
    # => [leaf_pos, chain_mmr_ptr, AUTH_DIGEST]

    # get the chain MMR leaf associated with the block the note was created in
    exec.mmr::get
    # => [MMR_LEAF, AUTH_DIGEST]

    # prepare the stack to read the sub hash and note root from the advice provider
    locaddr.0 padw padw padw
    # => [PAD, PAD, PAD, mem_ptr, MMR_LEAF, AUTH_DIGEST]

    # read the core hash and note root from the advice provider
    adv_pipe hperm
    # => [PERM, PERM, PERM, mem_ptr', MMR_LEAF, AUTH_DIGEST]

    # extract the digest and assert it matches MMR_LEAF
    dropw movup.8 drop movupw.2
    assert_eqw.err=ERR_PROLOGUE_NOTE_MMR_DIGEST_MISMATCH
    # => [AUTH_DIGEST]

    # load the note root from memory
    loc_loadw.1 swapw
    # => [AUTH_DIGEST, NOTE_ROOT]

    # load the index of the note
    adv_push.1 movdn.4
    # => [AUTH_DIGEST, note_index, NOTE_ROOT]

    # get the depth of the note tree
    exec.constants::get_note_tree_depth movdn.4
    # => [AUTH_DIGEST, depth, note_index, NOTE_ROOT]

    # verify the note hash
    mtree_verify
    # => [AUTH_DIGEST, depth, note_index, NOTE_ROOT]

    # clean the stack
    dropw drop drop dropw
    # => []
end

#! Reads data for the ith input note from the advice provider and stores it in memory at the
#! appropriate memory address. This includes computing and storing the nullifier and the
#! note hash.
#!
#! Stack: [idx]
#! Advice stack: [SN, SR, IR, VR, NI, NA, A0, ..., An]
#! Output: []
#!
#! Where:
#! - idx is the index of the input note.
#! - SN is the serial number of input note `idx`.
#! - SR is the script root of input note `idx`.
#! - IR is the inputs root of input note `idx`.
#! - VR is the vault root of input note `idx`.
#! - NI is the number of inputs in input note `idx`.
#! - NA is the number of assets in input note `idx`.
#! - A0..An are the assets of input note `idx`.
proc.process_input_note
    # read core note data
    # ---------------------------------------------------------------------------------------------

    # dup the note index
    dup
    # => [idx, idx]

    # compute address to store note hash
    exec.memory::get_consumed_note_ptr
    # => [note_ptr, idx]

    # compute address to store core note data
    dup exec.memory::get_consumed_note_core_ptr
    # => [note_data_ptr, note_ptr, idx]

    # read nullifier data from the advice provider (serial_num, script_hash, input_hash, asset_hash)
    padw padw padw adv_pipe hperm adv_pipe hperm
    # => [PERM, PERM, PERM, note_data_ptr + 4, note_ptr, idx]

    # extract nullifier
    exec.native::state_to_digest movup.4 drop
    # => [NULLIFIER, note_ptr, idx]

    # compute address for nullifier
    movup.6 exec.memory::get_consumed_note_nullifier_ptr
    # => [nullifier_ptr, NULLIFIER, note_ptr]

    # store nullifier in memory and drop from stack
    mem_storew dropw
    # => [note_ptr]

    # ingest note metadata
    # ---------------------------------------------------------------------------------------------

    # get the metadata from the advice provider and store in memory
    padw adv_loadw dup.4
    # => [note_ptr, NOTE_META, note_ptr]

    exec.memory::set_consumed_note_metadata
    # => [note_ptr]

    # ingest note args
    # ---------------------------------------------------------------------------------------------

    # get the note args from the advice provider and store in memory
    padw adv_loadw dup.4
    # => [note_ptr, NOTE_ARGS, note_ptr]

    exec.memory::set_consumed_note_args
    # => [note_ptr]

    # ingest number of note inputs
    # ---------------------------------------------------------------------------------------------

    # get the number of inputs from the advice provider and store it in memory
    adv_push.1 dup dup.2
    exec.memory::set_consumed_note_num_inputs
    # => [num_inputs, note_ptr]

    # make sure the number of inputs is in the valid range
    exec.constants::get_max_inputs_per_note lte
    assert.err=ERR_PROLOGUE_NOTE_TOO_MANY_INPUTS
    # => [note_ptr]

    # ingest note assets
    # ---------------------------------------------------------------------------------------------

    # get the number of assets from the advice provider and store it in memory
    adv_push.1 dup dup.2
    exec.memory::set_consumed_note_num_assets
    # => [num_assets, note_ptr]

    # assert the number of assets is within limits
    dup exec.constants::get_max_assets_per_note lte
    assert.err=ERR_PROLOGUE_NOTE_TOO_MANY_ASSETS
    # => [num_assets, note_ptr]

    # round up the number of assets to the next multiple of 2 (simplifies reading of assets)
    dup push.1 u32and add
    # => [rounded_num_assets, note_ptr]

    # initiate counter for assets
    push.0
    # => [counter, rounded_num_assets, note_ptr]

    # prepare address and stack for reading assets
    dup.2 exec.memory::get_consumed_note_assets_ptr padw padw padw
    # => [PAD, PAD, PADW, assets_ptr, counter, rounded_num_assets, note_ptr]

    # check if the number of assets is greater then 0
    dup.14 dup.14 neq
    # => [should_loop, PAD, PAD, PAD, assets_ptr, counter, rounded_num_assets, note_ptr]

    # loop and read assets from the advice provider
    while.true
        # read assets from advice provider
        adv_pipe hperm
        # => [PERM, PERM, PERM, assets_ptr, counter, rounded_num_assets, note_ptr]

        # check if we should loop again
        movup.13 push.2 add dup movdn.14 dup.15 neq
        # => [should_loop, PERM, PERM, PERM, assets_ptr, counter, rounded_num_assets, note_ptr]
    end
    # => [PERM, PERM, PERM, assets_ptr, counter, rounded_num_assets, note_ptr]

    # extract digest
    exec.native::state_to_digest
    # => [DIG, assets_ptr, counter, rounded_num_assets, note_ptr]

    # clean and rearrange stack
    swapw drop drop drop dup movdn.5
    # => [note_ptr, DIG, note_ptr]

    # get expected note vault from memory
    exec.memory::get_consumed_note_assets_hash
    # => [V, DIG, note_ptr]

    # assert that the computed hash matches the expected hash
    assert_eqw.err=ERR_PROLOGUE_NOTE_CONSUMED_ASSETS_MISMATCH
    # => [note_ptr]

    # TODO: make sure the last asset is not [ZERO; 4]?

    # insert note assets into the input vault
    # ---------------------------------------------------------------------------------------------
    #Â prepare stack for iteration over note assets
    exec.memory::get_input_vault_root_ptr dup.1 exec.memory::get_consumed_note_assets_ptr
    # => [assets_start_ptr, input_vault_root_ptr, note_ptr]

    # calculate assets end ptr
    dup dup.3 exec.memory::get_consumed_note_num_assets add swap
    # => [assets_start_ptr, assets_end_ptr, input_vault_root_ptr, note_ptr]

    # loop over assets and insert them into input vault

    # assess if we should loop
    dup.1 dup.1 neq
    # => [should_loop, assets_start_ptr, assets_end_ptr, input_vault_root_ptr, note_ptr]

    while.true
        # duplicate input_vault_root_ptr
        dup.2
        # => [input_vault_root_ptr, assets_start_ptr, assets_end_ptr, input_vault_root_ptr, note_ptr]

        # read the asset from memory
        padw dup.5 mem_loadw
        # => [ASSET, input_vault_root_ptr, assets_start_ptr, assets_end_ptr, input_vault_root_ptr, note_ptr]

        # insert asset into input vault
        exec.asset_vault::add_asset dropw
        # => [assets_start_ptr, assets_end_ptr, input_vault_root_ptr, note_ptr]

        # increment assets_start_ptr and asses if we should loop again
        add.1 dup.1 dup.1 neq
        # => [should_loop, assets_start_ptr, assets_end_ptr, input_vault_root_ptr, note_ptr]
    end

    # clean stack
    drop drop drop

    # compute note hash
    # ---------------------------------------------------------------------------------------------

    # TODO: This should be optimized using the `hperm` operation

    # serial number hash - serial_hash = hmerge(serial_number, 0)
    dup exec.memory::get_consumed_note_serial_num padw hmerge
    # => [SERIAL_HASH, note_ptr]

    # hash serial_hash with script hash - merge_script = hmerge(serial_hash, script_hash)
    dup.4 exec.memory::get_consumed_note_script_root hmerge
    # => [MERGE_SCRIPT, note_ptr]

    # hash merge_script with inputs hash - recipient = hmerge(merge_script, inputs_hash)
    dup.4 exec.memory::get_consumed_note_inputs_hash hmerge
    # => [RECIPIENT, note_ptr]

    # hash recipient with vault hash - note_hash = hmerge(recipient, vault_hash)
    dup.4 exec.memory::get_consumed_note_assets_hash hmerge
    # => [NOTE_HASH, note_ptr]

    # store note hash in memory and clear stack
    dup.4 exec.memory::set_consumed_note_hash
    # => [NOTE_HASH]

    # load the note metadata
    movup.4 exec.memory::get_consumed_note_metadata
    # => [NOTE_META, NOTE_HASH]

    # merge the note hash with the note metadata to compute authentication digest
    hmerge
    # => [AUTH_DIGEST]

    exec.authenticate_note
end

#! Process the input notes data provided via the advice provider. This involves reading the data
#! from the advice provider and storing it at the appropriate memory addresses. As each note is
#! processed its hash and nullifier are computed. The transaction nullifier commitment is computed via
#! a sequential hash of all (nullifier, ZERO) pairs for all input notes.
#!
#! Stack: []
#! Advice stack: [num_notes],
#! Advice map: { NULLIFIER_COMMITMENT => [(SN, SR, IR, VR, M, NA, A0, ..., An){num_notes}] }
#! Output: []
#!
#! - num_notes is the number of input notes.
#! - NULLIFIER_COMMITMENT, sequential hash of all input notes' nullifiers.
#! - SN is the serial number of the nth input note.
#! - SR is the script root of the nth input note.
#! - IR is the inputs root of the nth input note.
#! - VR is the vault root of the nth input note.
#! - M is the metadata of the nth input note.
#! - NA are optional note args for the nth input note.
#! - A0..An are the assets of the nth input note.
proc.process_input_notes_data
    # get the number of input notes from the advice stack
    adv_push.1
    # => [num_notes, ...]

    # assert the number of input notes is within limits; since max number of input notes is
    # expected to be smaller than 2^32, we can use a more efficient u32 comparison
    dup
    exec.constants::get_max_num_consumed_notes u32assert2.err=ERR_PROLOGUE_TOO_MANY_INPUT_NOTES
    u32lte assert.err=ERR_PROLOGUE_TOO_MANY_INPUT_NOTES
    # => [num_notes, ...]

    # if there are input notes, load input notes data from the advice map onto the advice stack
    dup neq.0
    if.true
        exec.memory::get_nullifier_commitment adv.push_mapval dropw
    end
    # => [num_notes, ...]

    # store the number of input notes into kernel memory
    dup exec.memory::set_total_num_consumed_notes
    # => [num_notes, ...]

    # loop over input notes and read data
    # ---------------------------------------------------------------------------------------------

    # initialize counter of already processed notes
    push.0
    # => [num_processed_notes = 0, num_notes, ...]

    # check if the number of input notes is greater then 0. Conditional for the while loop.
    dup.1 dup.1 neq
    # => [has_more_notes, num_processed_notes, num_notes, ...]

    # loop and read note data from the advice provider
    while.true
        dup exec.process_input_note
        # => [num_processed_notes, num_notes, ...]

        # increment processed note counter and check if we should loop again
        add.1 dup.1 dup.1 neq
        # => [has_more_notes, num_processed_notes + 1, num_notes, ...]
    end

    # drop counter
    drop
    # => [num_notes, ...]

    # compute nullifier commitment
    # ---------------------------------------------------------------------------------------------

    # initiate counter of notes processed for nullifier hashing
    push.0
    # => [num_processed_notes = 0, num_notes, ...]

    # initialize the hasher's state
    padw padw padw
    # => [R1, R0, CAP, num_processed_notes, num_notes, ...]

    # check if the number of input notes is greater then 0. Conditional for the while loop.
    dup.13 dup.13 neq
    # => [has_more_notes, R1, R0, CAP, num_processed_notes, num_notes, ...]

    # compute the nullifier commitment from the advice stack data
    while.true
        # hasher operates in overwrite mode, drop rate words
        dropw dropw

        # ingest next pair `(NULLIFIER, ZERO)`
        dup.4 exec.memory::get_consumed_note_nullifier padw hperm
        # => [PERM, PERM, CAP, num_processed_notes, num_notes, ...]

        # increment processed note counter and check if we should loop again
        movup.12 add.1 dup movdn.13 dup.14 neq
        # => [has_more_notes, PERM, PERM, CAP, num_processed_notes + 1, num_notes, ...]
    end

    # extract nullifier hash
    exec.native::state_to_digest
    # => [NULLIFIER_COMMITMENT, num_processed_notes + 1, num_notes, ...]

    # assert nullifier hash is what we would expect; when there are no input notes, the nullifier
    # hash should be [ZERO; 4] because the while loop above was not entered and, thus, hperm
    # instruction was not executed.
    exec.memory::get_nullifier_commitment
    assert_eqw.err=ERR_PROLOGUE_INPUT_NOTES_NULLIFIER_COMMITMENT_MISMATCH
    # => [num_processed_notes + 1, num_notes, ...]

    # clear stack
    drop drop
    # => [...]

    # set the current input note pointer to the first input note
    push.0 exec.memory::get_consumed_note_ptr exec.memory::set_current_consumed_note_ptr
    # => [...]
end

# TRANSACTION SCRIPT
# =================================================================================================

#! Reads the transaction script root from the advice provider stack and stores the root at the
#! appropriate memory address.
#!
#! Advice Stack: [TXSR]
#! Stack: []
#! Output: []
#!
#! - TXSR is the transaction script root.
proc.process_tx_script_root
    # read the transaction script root from the advice stack
    adv_loadw
    # => [TXSR]

    # store the transaction script root in memory
    exec.memory::set_tx_script_root
    # => []
end

# TRANSACTION PROLOGUE
# =================================================================================================

#! The transaction prologue is executed at the beginning of a transaction. Its responsibility is:
#! 1. "Unhash" inputs, authenticate the data and store it in the root contexts memory.
#! 2. Build a single vault containing assets of all inputs (input notes combined with current
#!    account vault).
#! 3. Verify that all input notes are present in the note db.
#!
#! Errors:
#!  - If data provided by the advice provider does not match global inputs.
#!  - The account data is invalid.
#!  - Any of the input notes do note exist in the note db.
#!
#! Operand stack: [BLOCK_HASH, account_id, INITIAL_ACCOUNT_HASH, NULLIFIER_COMMITMENT]
#! Advice stack: [
#!     PREVIOUS_BLOCK_HASH,
#!     CHAIN_MMR_HASH,
#!     ACCOUNT_ROOT,
#!     NULLIFIER_ROOT,
#!     BATCH_ROOT,
#!     PROOF_HASH,
#!     [block_num, version, timestamp, 0],
#!     ZERO,
#!     NOTE_ROOT,
#!     [account_id, 0, 0, account_nonce],
#!     ACCOUNT_VAULT_ROOT,
#!     ACCOUNT_STORAGE_ROOT,
#!     ACCOUNT_CODE_ROOT,
#!     number_of_input_notes,
#!     TX_SCRIPT_ROOT,
#! ]
#! Advice map: {
#!      NULLIFIER_COMMITMENT: [NOTE_DATA_1, ..., NOTE_DATA_N],
#!      CHAIN_MMR_HASH: [[num_blocks, 0, 0, 0], PEAK_1, ..., PEAK_N],
#! }
#! Output: []
#!
#! - BLOCK_HASH, reference block for the transaction execution.
#! - account_id, the account that the transaction is being executed against.
#! - INITIAL_ACCOUNT_HASH, account state prior to the transaction, ZERO for new accounts.
#! - NULLIFIER_COMMITMENT, sequential hash of all input notes' nullifiers.
#! - PREVIOUS_BLOCK_HASH, hash of the previous block.
#! - CHAIN_MMR_HASH, sequential hash of the reference MMR.
#! - ACCOUNT_ROOT, tree with latest account states.
#! - NULLIFIER_ROOT, epoch tree with nullifiers of consumed notes.
#! - BATCH_ROOT, tree of batches included in the block.
#! - PROOF_HASH, hash of the block's stark proof.
#! - block_num, the reference block number.
#! - version, the current protocol version.
#! - timestamp, the current timestamp.
#! - NOTE_ROOT, tree with created notes.
#! - account_nonce, account's nonce.
#! - ACCOUNT_VAULT_ROOT, account's vault root.
#! - ACCOUNT_STORAGE_ROOT, account's storage root.
#! - ACCOUNT_CODE_ROOT, account's code root.
#! - number_of_input_notes, number of input notes.
#! - TX_SCRIPT_ROOT, the transaction's script root.
#! - NOTE_DATA_1 .. NOTE_DATA_N, the data of the input notes.
#! - num_blocks, is the number of blocks in the MMR.
#! - PEAK_1 .. PEAK_N, are the MMR peaks.
export.prepare_transaction
    exec.process_global_inputs
    # => []

    exec.process_block_data
    exec.process_chain_data
    exec.process_account_data
    exec.process_input_notes_data
    exec.process_tx_script_root
    # => []
end
